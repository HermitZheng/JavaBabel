# Redis基本知识

Redis的数据是分布在内存中的，读写速度非常快，因此被广泛用于缓存。另外，Redis也经常被用作分布式锁。

高并发：直接操作缓存能够承受的请求远远大于直接访问数据库，从而一部分请求不用访问数据库。

## 为什么不用Map而用Redis做缓存？

1. Redis**基于内存**，可以使用**较大的空间**；而Map在JVM中无法使用较大空间，同时会给JVM造成负担
2. Redis还可以**持久化**，而Map只要JVM重启数据就会丢失
3. 使用Redis或memcached之类的称为**分布式缓存**，在多实例的情况下，各实例共用一份缓存数据，**缓存具有一致性**。缺点是需要保持redis或memcached服务的高可用，整个程序架构上较为复杂。
4. Redis有过期时间等一系列功能和计算API，而Map较为简单
5. Redis可以**独立部署**，而Map要依赖于JVM
6. Redis**支持多种数据结构**，且底层是C编写的，又因为是基于内存，因而计算速度相当快



## 数据结构

Redis的存储是以`key-value`的形式的。Redis中的**key一定是字符串String**，value可以是string、list、hash、set、zset这几种常用的。

| 数据类型 | 可以存储的值           | 操作                                                         |
| -------- | ---------------------- | ------------------------------------------------------------ |
| STRING   | 字符串、整数或者浮点数 | 对整个字符串或者字符串的其中一部分执行操作，对整数和浮点数执行自增或者自减操作 |
| LIST     | 列表                   | 从两端压入或者弹出元素，对单个或者多个元素进行修剪，只保留一个范围内的元素 |
| SET      | 无序集合               | 添加、获取、移除单个元素，检查一个元素是否存在于集合中，计算交集、并集、差集，从集合里面随机获取元素 |
| HASH     | 包含键值对的无序散列表 | 添加、获取、移除单个键值对，获取所有键值对，检查某个键是否存在 |
| ZSET     | 有序集合               | 添加、获取、删除元素，根据分值范围或者成员来获取元素，计算一个键的排名 |

Redis并**没有直接使用**这些数据结构来实现`key-value`数据库，而是**基于**这些数据结构创建了一个**对象系统**。

Redis使用对象来表示数据库中的键和值。每次我们在Redis数据库中新创建一个键值对时，**至少会创建出两个对象**。一个是**键对象**，一个是**值对象**。

### SDS简单动态字符串

简单动态字符串(Simple dynamic string，SDS)

```c++
struct sdshdr{
    // 字节数组，用于保存字符串
    char buf[];

    // 记录buf数组中已使用的字节数量，也是字符串的长度
    int len;

    // 记录buf数组未使用的字节数量
    int free;
}
```

1. sdshdr数据结构中用len属性记录了字符串的长度。那么**获取字符串的长度时，时间复杂度只需要O(1)**。
2. SDS不会发生溢出的问题，如果修改SDS时，空间不足。先会扩展空间，再进行修改！(**内部实现了动态扩展机制**)。
3. SDS可以**减少内存分配的次数**(空间**预分配**机制)。在扩展空间时，除了分配修改时所必要的空间，还会分配额外的空闲空间(**free 属性**)。
4. SDS是**二进制安全的**，所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据。它并不像C语言那样，使用'\0'作为判定一个字符串的结尾（'\0后面的都会被忽略'），而是使用了独立的len，这样可以保证**即使存储的数据中有'\0'这样的字符,它也是可以支持读取的。**



### 链表

```C
typedef struct listNode{
    //前置节点
    strcut listNode  *pre;

    //后置节点
    strcut listNode  *pre;

    //节点的值
    void  *value;
}listNode

typedef struct list{
    //表头结点
    listNode  *head;

    //表尾节点
    listNode  *tail;

    //链表长度
    unsigned long len;

    //节点值复制函数
    void *(*dup) (viod *ptr);

    //节点值释放函数
    void  (*free) (viod *ptr);

    //节点值对比函数
    int (*match) (void *ptr,void *key);
}list
```

Redis的链表有以下特性：

- **无环双向链表**
- 获取表头指针，表尾指针，获取链表节点长度的时间复杂度均为O(1)
- 链表使用`void *`指针来保存节点值，可以保存各种不同类型的值



### 哈希表

**哈希表结点：**

```C
typedef struct dictht{
    //哈希表数组
    dictEntry **table;  

    //哈希表大小
    unsigned long size;    

    //哈希表大小掩码，用于计算索引值
    //总是等于size-1
    unsigned long sizemark;     

    //哈希表已有节点数量
    unsigned long used;
}dictht
    
typedef struct dictEntry {
    //键
    void *key;

    //值
    union {
    void *value;
    uint64_tu64;
    int64_ts64;
    }v;    

    //指向下个哈希节点，组成链表
    struct dictEntry *next;
}dictEntry;
```

**字典：**

http://redisbook.com/preview/dict/datastruct.html

<img src="C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200409151301123.png" alt="image-20200409151301123" style="zoom:80%;" />

**实际上Redis维护了两个哈希表**：

- ht[0]：用于存放**真实**的`key-vlaue`数据
- ht[1]：用于**扩容(rehash)**

Redis中哈希算法和哈希冲突跟Java实现的差不多，它俩**差异**就是：

- Redis哈希冲突时：是将新节点添加在链表的**表头**。
- JDK1.8后，Java在哈希冲突时：是将新的节点添加到链表的**表尾**。

#### rehash扩容或收缩

在对哈希表进行扩展或者收缩操作时，reash过程并不是一次性地完成的，而是**渐进式**地完成的。

Redis在rehash时采取渐进式的原因：**数据量如果过大的话，一次性rehash会有庞大的计算量，这很可能导致服务器一段时间内停止服务**。

Redis具体是rehash时这么干的：

- 1. 在字典中维持一个索引计数器变量rehashidx，并将设置为0，表示rehash开始。
- 2. 在rehash期间每次对字典进行增加、查询、删除和更新操作时，**除了执行指定命令外**；还会将ht[0]中rehashidx索引上的值**rehash到ht[1]**，操作完成后rehashidx+1。
- 3. 字典操作不断执行，最终在某个时间点，所有的键值对完成rehash，这时**将rehashidx设置为-1，表示rehash完成**
- 4. 在渐进式rehash过程中，字典会同时使用两个哈希表ht[0]和ht[1]，所有的更新、删除、查找操作也会在两个哈希表进行。例如要查找一个键的话，**服务器会优先查找ht[0]，如果不存在，再查找ht[1]**，诸如此类。此外当执行**新增操作**时，新的键值对**一律保存到ht[1]**，不再对ht[0]进行任何操作，以保证ht[0]的键值对数量只减不增，直至变为空表。
- 5. 当 `ht[0]` 包含的所有键值对都迁移到了 `ht[1]` 之后 （`ht[0]` 变为空表）， 释放 `ht[0]` ， **将 `ht[1]` 设置为 `ht[0]`** ， 并在 `ht[1]` 新创建一个空白哈希表， 为下一次 rehash 做准备。



### 跳跃表（skiplist）

跳跃表(skiplist)是实现sortset(**有序**集合)的底层数据结构之一。

Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成。其中**zskiplist保存跳跃表的信息**(表头，表尾节点，长度)，**zskiplistNode则表示跳跃表的节点**。

跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。

![image-20200409153500301](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200409153500301.png)

在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。

![image-20200409153515013](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200409153515013.png)

与红黑树等平衡树相比，跳跃表具有以下优点：

- **插入速度**非常快速，因为**不需要**进行旋转等操作来**维护平衡性**；
- 更容易实现；
- 支持无锁操作。



### 整数集合(intset)

整数集合是set(集合)的底层数据结构之一。当一个set(集合)**只包含整数值元素**，并且**元素的数量不多**时，Redis就会采用整数集合(intset)作为set(集合)的底层实现。

整数集合(intset)保证了元素是**不会出现重复**的，并且是**有序**的(从小到大排序)。

```c
typeof struct intset {
        // 编码方式
        unit32_t encoding;
        // 集合包含的元素数量
        unit32_t lenght;
        // 保存元素的数组
        int8_t contents[];
} intset;
```

![image-20200409154102010](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200409154102010.png)

**contents数组的真正类型取决于encoding属性的值**：

- INTSET_ENC_INT16
- INTSET_ENC_INT32
- INTSET_ENC_INT64 （能保存的数字范围不同）

如果本来是INTSET_ENC_INT16的编码，想要存放大于INTSET_ENC_INT16编码能存放的整数值，此时就得编码**升级**(从16升级成32或者64)。步骤如下：

- 1）根据**新元素类型**拓展整数集合底层数组的空间并为新元素分配空间。
- 2）将底层数组**现有的所有元素**都转换成与新元素相同的类型，并将类型转换后的元素放到正确的位上，需要维持底层数组的**有序**性质不变。
- 3）将新元素添加到底层数组。

另外一提：**只支持升级操作，并不支持降级操作**。



### 压缩列表（ziplist）

压缩列表（ziplist）是**列表键**和**哈希键**的底层实现之一。当一个**列表键**只包含**少量**列表项， 并且每个列表项要么就是**小整数值**， 要么就是**长度比较短**的**字符串**， 那么 Redis 就会使用压缩列表来做列表键的底层实现。

压缩列表(ziplist)是Redis为了**节约内存**而开发的，是由一系列的**特殊编码的连续内存块**组成的**顺序性**数据结构。

因为节点的 `previous_entry_length` 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据**当前节点的起始地址来计算出前一个节点的起始地址**（可以倒序遍历）。

![image-20200409160833454](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200409160833454.png)

压缩列表从表尾节点**倒序遍历**，首先指针通过zltail偏移量指向表尾节点，然后通过指向**节点记录的前一个节点的长度依次向前遍历访问整个压缩列表**。



## 对象

Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们**至少**会创建**两个对象**， 一个对象用作键值对的键（**键对象**）， 另一个对象用作键值对的值（**值对象**）。

以下是不同类型的编码以及对象：

| 类型           | 编码                        | 对象                                                 |
| :------------- | :-------------------------- | :--------------------------------------------------- |
| `REDIS_STRING` | `REDIS_ENCODING_INT`        | 使用整数值实现的字符串对象。                         |
| `REDIS_STRING` | `REDIS_ENCODING_EMBSTR`     | 使用 `embstr` 编码的简单动态字符串实现的字符串对象。 |
| `REDIS_STRING` | `REDIS_ENCODING_RAW`        | 使用简单动态字符串实现的字符串对象。                 |
| `REDIS_LIST`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的列表对象。                         |
| `REDIS_LIST`   | `REDIS_ENCODING_LINKEDLIST` | 使用双端链表实现的列表对象。                         |
| `REDIS_HASH`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的哈希对象。                         |
| `REDIS_HASH`   | `REDIS_ENCODING_HT`         | 使用字典实现的哈希对象。                             |
| `REDIS_SET`    | `REDIS_ENCODING_INTSET`     | 使用整数集合实现的集合对象。                         |
| `REDIS_SET`    | `REDIS_ENCODING_HT`         | 使用字典实现的集合对象。                             |
| `REDIS_ZSET`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的有序集合对象。                     |
| `REDIS_ZSET`   | `REDIS_ENCODING_SKIPLIST`   | 使用跳跃表和字典实现的有序集合对象。                 |

### 字符串（String）

string类型有三种**编码格式**：

- int：整数值，这个整数值可以使用long类型来表示

- - 如果是浮点数，那就用embstr或者raw编码。具体用哪个就看这个数的长度了

- embstr：字符串值，这个字符串值的长度**小于**32字节

- raw：字符串值，这个字符串值的长度**大于**32字节

embstr和raw的**区别**：

- raw分配内存和释放内存的次数是两次，embstr是一次
- embstr编码的数据保存在一块**连续**的内存里面

编码之间的**转换**：

- int类型如果存的**不再是一个整数值**，则会从int转成raw
- embstr是**只读**的，在修改的时候回从embstr转成raw



### 列表（List）

list类型有两种**编码格式**：

- ziplist：字符串元素的长度**都小于**64个字节`&&`总数量**少于**512个
- linkedlist：字符串元素的长度**大于**64个字节`||`总数量**大于**512个

编码之间的**转换：**

- 原本是ziplist编码的，如果保存的数据长度太大或者元素数量过多，会转换成linkedlist编码。



### 哈希（Hash）

hash类型有两种**编码格式**：

- ziplist：key和value的字符串长度**都小于**64字节`&&`键值对总数量**小于**512
- hashtable：key和value的字符串长度**大于**64字节`||`键值对总数量**大于**512

编码之间的**转换：**

- 原本是ziplist编码的，如果保存的数据长度太大或者元素数量过多，会转换成hashtable编码。



### 集合（Set）

set类型有两种**编码格式**：

- intset：保存的元素**全都是整数**`&&`总数量**小于**512
- hashtable：保存的元素**不是整数**`||`总数量**大于**512

编码之间的**转换：**

- 原本是intset编码的，如果保存的数据不是整数值或者元素数量大于512，会转换成hashtable编码。



### 有序集合（Sort Set）

set类型有两种**编码格式**：

- ziplist：元素长度**小于**64`&&`总数量**小于**128
- skiplist：元素长度**大于**64`||`总数量**大于**128

<img src="C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200409170032173.png" alt="image-20200409170032173" style="zoom:80%;" />

有序集合(sortset)对象**同时采用skiplist和哈希表（字典）来实现**：

- skiplist能够达到插入的时间复杂度为O(logn)，根据成员查分值的时间复杂度为O(1)

<img src="C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200409170049273.png" alt="image-20200409170049273" style="zoom: 80%;" />

编码之间的**转换：**

- 原本是ziplist编码的，如果保存的数据长度大于64或者元素数量大于128，会转换成skiplist编码的。



## 过期时间（Expire）

设置键的生存、过期时间：

- 设置键的**生存**时间可以通过`EXPIRE`或者`PEXPIRE`命令。

- 设置键的**过期**时间可以通过`EXPIREAT`或者`PEXPIREAT`命令。

- 其中，前三种命令都会转换成第四种命令：

  ![image-20200410202738275](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200410202738275.png)

查看键的生存时间相关信息：

- PERSIST(**移除**过期时间)
- TTL(Time To Live)返回**剩余**生存时间，以秒为单位
- PTTL以**毫秒为单位**返回键的剩余生存时间

### 过期的实现

```c
typedef struct redisDb {
    dict *dict;                 /* The keyspace for this DB */
    dict *expires;              /* Timeout of keys with a timeout set */
    ...
}
```

可见在 redisDb 结构的 **expire 字典**（过期字典）保存了所有键的过期时间：

- 过期字典的**键**是一个指向键空间中的**某个键对象的指针**

- 过期字典的**值**保存了键所指向的数据库键的**过期时间**

**过期键的判断**：通过查询过期字典，检查下面的条件判断是否过期

1. 检查给定的键是否在过期字典中，如果存在就获取键的过期时间
2. 检查当前 UNIX 时间戳是否**大于**键的过期时间，是就过期，否则未过期

### 过期策略

删除策略可分为三种

- 定时删除(对内存友好，对CPU不友好)

	- 到时间点上就把所有过期的键删除了。

- 惰性删除(对CPU极度友好，对内存极度不友好)

   - 每次**从键空间取键**的时候，判断一下该键是否过期了，如果过期了就删除。

- 定期删除(折中)

   - **每隔**一段时间去删除过期键，**限制**删除的**执行时长**和**频率**。

Redis采用的是**惰性删除+定期删除**两种策略，所以说，在Redis里边如果过期键到了过期的时间了，未必被立马删除的。



### 内存淘汰机制

当有大量的键没有设置过期时间，也没有被惰性删除，导致内存被大量占用时，Redis有内存淘汰机制来淘汰这部分数据。我们可以设置内存最大使用量，当内存使用量超出时，会施行**数据淘汰策略**。

首先要配置maxmemory值

1. 客户端发起了需要**申请**更多内存的命令（如set）。

2. Redis检查内存使用情况，如果**已使用的内存大于**maxmemory则开始根据用户配置的不同淘汰策略来淘汰内存（key），从而换取一定的内存。

3. 如果上面都没问题，则这个命令执行成功。

maxmemory为0的时候表示我们对Redis的内存使用**没有限制**。

Redis的内存淘汰机制有以下几种：

| 机制            | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| volatile-lru    | 从已设置过期时间的数据集（server.db[i].expires）中挑选**最近最少**使用的数据淘汰 |
| volatile-ttl    | 从已设置过期时间的数据集（server.db[i].expires）中挑选**将要过期**的数据淘汰 |
| volatile-random | 从已设置过期时间的数据集（server.db[i].expires）中**任意**选择数据淘汰 |
| allkeys-lru     | 从数据集（server.db[i].dict）中挑选**最近最少使用**的数据淘汰 |
| allkeys-random  | 从数据集（server.db[i].dict）中**任意**选择数据淘汰          |
| noeviction      | 禁止驱逐数据，当内存使用达到阈值的时候，所有引起申请内存的命令会**报错** |

设置方式 ：config set maxmemory-policy volatile-lru

使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是**热点数据**。可以将内存最大使用量设置为热点数据占用的内存量，然后启用**allkeys-lru**淘汰策略，将**最近最少使用**的数据淘汰。



## Redis持久化

Redis提供了两种不同的持久化方法来讲数据存储到硬盘里边：

- RDB(基于快照)，将**某一时刻的所有数据**保存到一个RDB文件中。
- AOF(append-only-file)，当Redis服务器执行**写命令**的时候，将执行的**写命令**保存到AOF文件中。

### RDB(快照持久化)

RDB持久化可以**手动**执行，也可以根据服务器配置**定期**执行。RDB持久化所生成的RDB文件是一个经过**压缩**的二进制文件，Redis可以通过这个文件**还原**数据库的数据。

有两个命令可以生成RDB文件：

- `SAVE`会**阻塞**Redis服务器进程，服务器不能接收任何请求，直到RDB文件创建完毕为止。
- `BGSAVE`创建出一个**子进程**，由子进程来负责创建RDB文件，服务器进程可以继续接收请求。

Redis服务器在**启动**的时候，如果发现有RDB文件，就会**自动**载入RDB文件(不需要人工干预)

- 服务器在载入RDB文件期间，会处于**阻塞**状态，直到载入工作完成。

还可以使用配置的方式来**定期**执行：

在默认的配置下，如果以下的条件被触发，就会执行`BGSAVE`命令

```
  save 900 1            #在900秒(15分钟)之后，至少有1个key发生变化，
  save 300 10           #在300秒(5分钟)之后，至少有10个key发生变化
  save 60 10000        	#在60秒(1分钟)之后，至少有10000个key发生变化
```



### AOF(文件追加)

AOF是通过保存Redis服务器所执行的**写命令**来记录数据库的数据的。

AOF持久化功能的实现可以分为3个步骤：

- 命令追加：命令写入aof_buf缓冲区
- 文件写入：调用flushAppendOnlyFile函数，考虑是否要将aof_buf缓冲区写入AOF文件中
- 文件同步：考虑是否将内存缓冲区的数据真正写入到硬盘

![image-20200409235434820](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200409235434820.png)

flushAppendOnlyFile函数的行为由服务器配置的**appendfsyn选项**来决定的：

```
    appendfsync always     # 每次有数据修改发生时都会写入AOF文件。
    appendfsync everysec   # 每秒钟同步一次，该策略为AOF的默认策略。
    appendfsync no         # 从不同步。高效但是数据不会被持久化。
```

AOF的数据恢复：

创建一个**伪客户端**(本地)来执行AOF的命令，直到AOF命令被全部执行完毕。

<img src="C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200409235536843.png" alt="image-20200409235536843" style="zoom:80%;" />

#### AOF重写

例如当对同一个列表进行多次Push操作时，多条命令其实可以合并为一条命令，从而**让AOF文件的体积变得更小**。AOF重写由Redis自行触发(参数配置)，也可以用`BGREWRITEAOF`命令**手动触发**重写操作。

- 要值得说明的是：**AOF重写不需要对现有的AOF文件进行任何的读取、分析。AOF重写是通过读取服务器当前数据库的数据来实现的**！

Redis将AOF重写程序放到**子进程**里执行(`BGREWRITEAOF`命令)，像`BGSAVE`命令一样fork出一个子进程来完成重写AOF的操作，从而不会影响到主进程。

AOF后台重写是不会阻塞主进程接收请求的，新的写命令请求可能会导致**当前数据库和重写后的AOF文件的数据不一致**！

为了解决数据不一致的问题，Redis服务器设置了一个**AOF重写缓冲区**，这个缓存区会在服务器**创建出子进程之后使用**。

<img src="C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200410000305669.png" alt="image-20200410000305669"  />

### RDB和AOF比较

#### 对过期键的策略

RDB持久化对过期键的策略：

- 执行`SAVE`或者`BGSAVE`命令创建出的RDB文件，程序会对数据库中的过期键检查，**已过期的键不会保存在RDB文件中**。
- **载入**RDB文件时，程序同样会对RDB文件中的键进行检查，**过期的键会被忽略**。

AOF持久化对过期键的策略：

- 如果数据库的键已过期，**但还没被惰性/定期删除**，AOF文件不会因为这个过期键产生任何影响(也就说会**保留**)，当过期的键被删除了以后，会追加一条**DEL命令**来显示记录该键被删除了
- 重写AOF文件时，程序会对RDB文件中的键进行检查，**过期的键会被忽略**。

复制模式：

- **主服务器来控制**从服务器统一删除过期键(保证主从服务器数据的一致性)

RDB和AOF并不互斥，它俩可以**同时使用**。

- RDB的优点：载入时**恢复数据快**、文件**体积小**。
- RDB的缺点：会一定程度上**丢失数据**(因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。)
- AOF的优点：**丢失数据少**(默认配置只丢失一秒的数据)。
- AOF的缺点：**恢复数据**相对较**慢**，文件**体积大**

如果Redis服务器**同时开启**了RDB和AOF持久化，服务器会**优先使用AOF文件**来还原数据(因为AOF更新频率比RDB更新频率要高，还原的数据更完善)



## 相关问题

**Redis为什么快？**

1. 使用C语言 贴近操作系统
2. Redis将所有数据放在内存中，非数据同步正常工作中，是不需要从磁盘读取数据的
3. Redis使用单线程简化算法的实现，并发的数据结构实现不但困难且测试也麻烦，单线程避免了线程切换以及加锁释放锁带来的消耗
4. 使用多路复用，自身的事件处理模型将epoll的read、write、close等都转换成事件，不在网络I/O上浪费过多的时间



