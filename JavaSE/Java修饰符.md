# Java修饰符

## 访问修饰符

Java中，可以使用**访问控制符来保护对类、变量、方法和构造方法的访问**。

Java支持4种不同的访问权限——

1. **public**对**所有类**可见，使用对象：类、接口、变量、方法。

被public修饰的成员 ，可以在任何一个类中被调用，不管同包或不同包，是**权限最**

**大**的一个修饰符。

2. **protected**对**同一包内的类和所有子类**可见，使用对象：变量、方法，不能修饰外

部类。

被protected修饰的成员，能在定义它们的类中，同包的类中被调用。

如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类。

3. **default**（缺省，什么也不写）在**同一包内**可见，不使用任何修饰符，使用对象：

类、接口、变量、方法。

默认权限即同包权限，同包权限的元素只能在定义它们的类中，以及同包的类中被调

用。

4. **private**在**同一类内**可见，使用对象：变量、方法，不能修饰外部类。

被private修饰的成员，只能在定义它们的类中使用，在其他类中不能调用。

| 修饰符      | 当前类 | 同一包内 | 子类(同一包) | 子类(不同包) | 其他包 |
| :---------- | :----- | :------- | :----------- | :----------- | :----- |
| `public`    | √      | √        | √            | √            | √      |
| `protected` | √      | √        | √            | √            | －     |
| `default`   | √      | √        | √            | －           | －     |
| `private`   | √      | －       | －           | －           | －     |

![img](https://uploadfiles.nowcoder.com/images/20180701/3807435_1530425536125_D49BCBCCF82CF58C566E12F1E3130070)



## 非访问修饰符

| **修饰符**             | **类** | **成员访求** | **构造方法** | **成员变量** | **局部变量** |
| ---------------------- | ------ | ------------ | ------------ | ------------ | ------------ |
| abstract（抽象的）     | √      | √            | －           | －           | －           |
| static （静态的）      | －     | √            | －           | √            | －           |
| synchronized（同步的） | －     | √            | －           | －           | －           |
| native（本地的）       | －     | √            | －           | －           | －           |
| transient（暂时的）    | －     | －           | －           | √            | －           |
| volatile（易失的）     | －     | －           | －           | √            | －           |
| final（最终的）        | √      | √            | －           | √            | √            |

 ### 1. abstract

**abstract**修饰符，可以修饰方法，类。

用abstract修饰的类叫做**抽象类**，抽象类不能被实例化。

用abstract修饰的方法叫做**抽象方法**，抽象方法没有方法体。

抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。

一个类不能同时被 abstract 和 final 修饰。

如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。

抽象类可以包含抽象方法和非抽象方法。

### 2. static

**static**修饰符，用来修饰成员变量和成员方法，也可以形成静态static代码块。

- **静态变量：**

  static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。

- **静态方法：**

  static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。

- **静态代码块：**

  用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。

- **静态导包：**

  用import static代替import静态导入包是**JDK1.5**中的新特性。

  ```java
  import static java.lang.Interger.*; //导入包中的所有的静态方法
  ```

### 3. final

**final**修饰符，可以用来修饰**类、方法和变量**（包括成员变量和局部变量）。

使用final修饰的变量一旦赋值后，不能被重新赋值；被 final 修饰的实例变量必须显式地指定初始值。

final 修饰符通常和 static 修饰符一起使用来创建类常量。

#### **final修饰类**

当用final修饰一个类时，表明**这个类不能被继承**。

如果一个类永远不会被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意**final类中的所有成员方法都会被隐式地指定为final方法**。

#### **final修饰方法**

用final关键字修饰方法，它**表示该方法不能被覆盖**。这种使用方式主要是从设计的角度考虑，即明确告知不希望去覆盖这个方法。这种方式我们很容易理解，然而，关于private和final关键字还有一点联系，这就是类中**所有的private方法都隐式地指定为是final的**，由于无法在类外使用private方法，所以也就无法覆盖它。

**使用final方法的原因：把方法锁定，防止任何继承类修改它的意义和实现；**

**高效，编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。**

#### **final修饰变量**

final变量（常量）用final修饰的成员变量**表示常量**，只能被赋值一次，赋值后值无法改变。final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。

对于一个final变量，如果是**基本数据类型的变量**，则其数值一旦**在初始化之后便不能更改**；如果是**引用类型的变量**，则在对其**初始化之后便不能再让其指向另一个对象**。

另外，final变量定义的时候，可以**先声明，而不给初值**，这种变量也称为**final空白**，无论什么情况，编译器都确保空白final在**使用之前**必须被初始化。

#### **final修饰参数**

当函数参数为final类型时，你**可以读取使用该参数，但是无法改变该参数的值**。

#### 匿名内部类

匿名内部类中要访问的**局部变量**必须使用final修饰。

在Java8之后，匿名内部类访问局部变量，该局部变量可以不用显式的用final修饰，因为Java8之后，会默认给匿名内部类要访问的变量用final修饰。

实际上，不仅是匿名内部类，即使是**普通内部类**，在其中访问局部变量，该局部变量都需要显式的或者隐式的(Java8之后)用final修饰。



### 4. native

**native**修饰符，用于修饰方法。

说明其修饰的方法是一个**原生态方法**，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。

Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。

### 5. **transient**

**transient**修饰符，只能用来修饰字段，在对象序列化的过程中，**标记为transient的变量不会被序列化**。

该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。

### 6. volatile 

 **volatile**修饰符，只能用来修饰变量，是Java提供的一种**轻量级的同步机制**。

它主要有两个特性：一是**保证共享变量对所有线程的可见性**；二是**禁止指令重排序优化**。

同时需要注意的是，**volatile对于单个的共享变量的读、写具有原子性**，但是像num++这种复合操作，volatile无法保证其原子性，解决方案就是使用并发包中的原子操作类，通过循环CAS的方式来保证num++操作的原子性。

- volatile无法实现原子性，只能实现可见性

- 当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。

- 由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字

- 在需要同步的时候，第一选择应该是synchronized关键字，这是最安全的方式，尝试其他任何方式都是有风险的。尤其在、jdK1.5之后，对synchronized同步机制做了很多优化，如：自适应的自旋锁、锁粗化、锁消除、轻量级锁等，使得它的性能明显有了很大的提升。

- 当且仅当满足以下所有条件时，才应该使用volatile变量：

1. 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
2. 该变量没有包含在具有其他变量的不变式中，防止影响其他变量
3. 防止代码重排

### 7. synchronized

**synchronized**修饰符，可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果 再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。

- 无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。

- 每个对象只有一个锁（lock）与之相关联。

- 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。

**synchronized关键字的作用域有二种：**

- 某个对象实例内：

  ```java
  synchronized aMethod(){}
  ```

  可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线 程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的 synchronized方法是不相干扰的；也就是说，其它线程照样可以同时访问相同类的**另一个对象实例**中的synchronized方法；

- 某个类的范围：

  ```java
  synchronized static aStaticMethod{}
  ```

  防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。

**synchronized 代码块：**

除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问，它的作用域是当前对象。

```java
synchronized(this){
	// 代码块	
}
```



| **类 修饰符**         | 简述                               |
| --------------------- | ---------------------------------- |
| Public                | 可以从其他类中访问                 |
| Abstract              | 本类不能被实例化                   |
| Final                 | 不能再声明子类                     |
| **构造函数修饰符**    |                                    |
| Public                | 可以从所有的类中访问               |
| Protected             | 只能从自己的类和它的子类中访问     |
| Private               | 只能在本类中访问                   |
| **域/成员变量修饰符** |                                    |
| Public                | 可以从所有的类中访问               |
| Protected             | 只能从本类和它的子类中访问         |
| Private               | 只能从本类中访问它                 |
| Static                | 对该类的所有实例只能有一个域值存在 |
| transient             | 不是一个对象持久状态的一部份       |
| Volatile              | 可以被异步的线程所修改             |
| final                 | 必须对它赋予初值并且不能修改它     |
| **局部变量 修饰符**   |                                    |
| final                 | 必须对它赋予初值并且不能修改它     |
| **方法修饰符**        |                                    |
| Public                | 可以从所有的类中访问它             |
| Protected             | 只能从本类及其子类中访问它         |
| Private               | 只能从本类中访问它                 |
| abstract              | 没有方法体，属于一个抽象类         |
| final                 | 子类不能覆盖它                     |
| static                | 被绑定于类本身而不是类的实例       |
| native                | 该方法由其他编程语言实现           |
| synchronized          | 在一个线程调用它之前必须先给它加   |





