# Java内存区域与内存溢出异常



## 运行时数据区域

#### 1. 程序计数器

一块较小的内存区域，可以看做是当前线程所执行的字节码的行号指示器。通过改变这个计数器的值来选取下一条需要执行的字节码指令，是程序控制流的指示器。

计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，计数器的值则应为空（Undefined）。

此内存区域是唯一一个规范中没有规定任何OutOfMemoryError情况的区域。

#### 2. Java虚拟机栈

每个方法被执行时都会同步创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。每一个方法被调用直至执行完毕的过程，都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

​		**局部变量表**

​		局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、		long、double）、对象引用（reference类型，不等同于对象本身，可以是一个指向对象起始地址的指针等）		和returnAddress类型（指向一条字节码指令的地址）。



这些数据类型以局部变量槽（Slot）来表示，其中64位长度的double和long占用两个变量槽，其余只占用一个。

可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小:

```java
java -Xss2M HackTheJava
```

该区域可能抛出以下异常：

- 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
- 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

#### 3. 本地方法栈

与虚拟栈所发挥的作用非常相似，区别是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用到的本地方法服务。

本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。

本地方法栈也会抛出 StackOverflowError和OutOfMemoryError异常。

#### 4. Java堆

被所有线程共享的一块区域，在虚拟机启动时创建。

此内存区域的唯一目的是存放**对象实例**，几乎所有对象实例都在这里分配内存，是垃圾收集器管理的内存区域（GC堆）。

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。一般可以将堆分成两块（经典分代）：

- 新生代（Young Generation）
- 老年代（Old Generation）

Java堆可以处于物理上不连续的内存空间中（不需要连续的内存），但在逻辑上它应该被视为连续的；能够可扩展的动态增加其内存。

如果在Java堆中没有内存来完成实例分配，并且堆也无法再扩展时会抛出OutOfMemoryError异常。

可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。

```java
java -Xms1M -Xmx2M HackTheJava
```

#### 5. 方法区

是各个线程共享的内存区域，它用于存放被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

这个区域的垃圾回收目标主要是针对常量池的回收和对类型的卸载，但是一般难以实现。

HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。

方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。

和堆一样不需要连续的内存，并且可以动态扩展；如果方法区无法满足新的内存分配需求时，会抛出 OutOfMemoryError 异常。

#### 6. 运行时常量区

运行时常量区是方法区的一部分。

Class文件中除了有类的版本、字段、方法、接口、等描述信息外，还有常量池表（用于存放编译器生成的各种字面量与符号引用），这部分内容将在类加载后存放到方法区的运行时常量池中。

除了在编译期生成的常量外，还可以动态生成，如String类的intern()方法。

#### 7. 直接内存

直接内存并不是虚拟机运行时数据区的一部分，但是也被频繁地使用；动态扩展时也会出现OutOfMemoryError 异常。

在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。

## 对象的创建

当虚拟机遇到一条new指令时，先去检查这个指令的参数是否能在常量池中定位到一个类的引用符号，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

#### 对象的内存分配

在类检查通过后，虚拟机将为新生对象分配内存。内存划分一般有两种：

##### 1. 指针碰撞（Bump The Pointer）

假设Java堆中内存是绝对规整的，所有被使用的内存都被放在一边，空闲的放在另一半，中间放着一个指针作为分界点的指示器。只需要移动指针就能完成内存的分配

##### 2. 空闲列表（Free List）

当被使用的内存和空闲内存相互交错在一起，虚拟机就需要维护一个列表来记录哪些内存块是可用的。在分配的时候从列表上找到足够大的内存块划分给对象实例，并更新列表的信息。

使用哪种分配方式由Java堆是否规整来决定，而堆是否规整又由垃圾收集器是否带有空间压缩整理功能决定。

#### 对象的内存布局

对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

对象头包含了存储对象自身的运行时数据和类型指针，即对象指向他的类型元数据的指针。

实例数据包含了我们在程序代码里所定义的各种类型的字段内容。

对齐填充则起到了占位符的作用（任何对象的大小都必须是8字节的整数倍）。

#### 对象的访问定位

主流的访问方式主要有使用句柄和直接指针两种。

##### 使用句柄

如果使用句柄访问方式，Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。

使用句柄方式最大的好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。

##### 使用直接指针

如果使用直接指针，Java堆对象的布局就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址。使用直接指针方式最大的好处就是***速度更快***，他**节省了一次指针定位的时间开销**。



<img src="C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200229141412777.png" alt="image-20200229141412777" style="zoom:80%;" />

![image-20200229141424786](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200229141424786.png)

## 虚拟机栈及栈帧

![image-20200304171153192](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200304171153192.png)