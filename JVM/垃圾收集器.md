# 垃圾收集器

## 经典垃圾收集器

几款经典垃圾收集器的分代以及搭配关系如图所示：

<img src="C:\Users\Hanabi\Desktop\深入理解JVM\qq_pic_merged_1583409821754.jpg" style="zoom: 33%;" />

### 并行与并发

- 并行：**多条垃圾收集器线程在同一时间协同工作**，默认此时用户线程处于等待状态
- 并发：**垃圾收集器线程与用户线程之间同一时间都在运行**，此时由于用户进程未被冻结，应用程序仍然能够相应请求；但因为垃圾收集器占用了一部分资源，应用程序的吞吐量将受到一定的影响。



### 1. Serial收集器

新生代收集器，基于标记-复制算法。

Serial收集器是一个**单线程**工作的收集器，它只会使用一个处理器或者一条线程去完成工作，而且在它工作时必须暂停其他所有进程直到收集结束。垃圾收集工作是由虚拟机自动发起和完成的，因此线程的停止对于用户是不可知、不可控的。

![image-20200305201212388](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200305201212388.png)

它是客户端模式下的默认收集器，与其他收集器的单线程相比，Serial简单而高效。

由于没有线程交互的开销，在单核或核心数较少的情况下，Serial的效率较高，同时额外内存开销也较小。

它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。



### 2. ParNew收集器

新生代收集器，基于标记-复制算法。

ParNew实质上是Serial的**多线程**并行版本，是不少运行在服务端模式下的HotSpot虚拟机。除了Serial以外，目前只有它能与CMS收集器配合工作。

![image-20200305201853713](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200305201853713.png)

在单核或者低核心数时，ParNew的效率并不会比Serial好。

从JDK9开始，ParNew合并入CMS，成为它专属的新生代收集器；从此ParNew和CMS只能互相搭配使用。



### 3. Parallel Scavenge收集器

新生代收集器，基于标记-复制算法，被称为“吞吐量优先收集器”。

它的专注目标是达到一个可控制的吞吐量，即处理器用于运行用户代码的时间与处理器总消耗时间的比值。

停顿时间越短就越适合需要与用户交互或保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以高效率地利用 CPU 资源，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的分析任务。

垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价的：把新生代调小会导致垃圾收集发生的更频繁。停顿时间下降了，但是吞吐量也下降了。

![image-20200305204717067](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200305204717067.png)

 -XX:+UseAdaptiveSizePolicy（自适应调节策略）是一个开关参数，开启之后就不需要指定新生代大小等各种参数，虚拟机会根据系统的运行情况收集性能监控信息以动态调整这些参数，以提供最合适的停顿时间和吞吐量。



### 4. Serial Old收集器

Serial Old是Serial的老年代版本，同样是单线程收集器，基于标记-整理算法。

这个收集器的主要意义是供客户端模式下的HotSpot使用。JDK5之前可以与Parallel Scavenge搭配。

它也可以作为CMS收集器发生失败后的后备预案，在并发发生Concurrent Mode Failure时使用。



### 5. Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法。

在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old组合。



### 6. CMS收集器

CMS收集器是一种以获取**最短回收停顿时间**为目标的收集器，基于标记-清除算法。

垃圾收集流程分为以下四个步骤：

- 初始标记：仅仅标记GC Roots能**直接关联**到的对象，速度很快，需暂停用户线程
- 并发标记：遍历整个对象图进行可达性分析，耗时较长但是不需要暂停用户线程
- 重新标记：修正并发标记期间因用户线程运作而发生**变动**的一部分对象的标记记录，比初始标记稍慢
- 并发清除：清除标记阶段已经判断死亡的对象，因为不需要移动对象，因而可与用户线程并发

耗时最长的并发标记和并发清除阶段都可以与用户线程一起工作，因而从总体上CMS的内存回收过程是与用户线程一起并发执行的。

![image-20200305212439100](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200305212439100.png)

CMS被称为“并发低停顿收集器”，至少有以下三个明显缺点：

- 对处理器资源非常敏感，虽然不会造成停顿，但是因为占用了一部分线程，导致应用程序变慢，降低总吞吐量
- 无法处理**浮动垃圾**，可能出现Concurrent Mode Failure进而导致Full GC的产生。由于当CMS运行时用户线程也同时运行，因而此时也会继续产生一部分垃圾对象，并且需要到下一次垃圾收集时才会被清除。也是由于垃圾收集和用户进程并发进行，所以需要**预留足够的内存空间**供用户使用，因此CMS不能等到老年代全部占满后在进行垃圾收集。当CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现Concurrent Mode Failure并发失败，此时虚拟器将启动**后备预案**：冻结用户线程，临时启用Serial Old，但这样停顿时间就长了
- 由于基于标记-清除算法，会产生大量空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC的情况。-XX:CMSFullCsBeforeCompaction参数要求CMS在执行若干次不整理空间的Full GC后，下一次进入Full GC之前先进行碎片整理。（此参数从JDK9开始废弃）



### 7. Garbage First收集器

Garbage First收集器（简称G1）设计思路是**面向局部收集**以及基于**Region**的内存布局形式。

G1能够建立起一个“**停顿时间模型**”，来指定在一个长度为M毫秒的时间片段里，消耗在垃圾收集上的时间不超过N毫秒，即可预测的停顿。

G1可以不用将收集范围限制在新生代或者老年代，又或者是整个Java堆；它可以面向堆内存的任何部分来组成回收集（Collection Set，CSet）进行回收，对收集区域的衡量标准从分代变为了存放垃圾数量最多、回收收益最大的区域，这就是G1的Mixed GC模式。

基于Region的堆内存布局不再坚持固定大小和数量的分代划分，而是把连续的Java堆划分为**多个大小相等的独立区域**（Region），每一个Region都可以根据需要扮演新生代的Eden、Survivor或者老年代空间。

![image-20200305230233863](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200305230233863.png)

Region中还有一类专门存储大对象的Humongous区域，G1认为只有大小超过了一个Region容量一半的对象即可判定为大对象，大多数情况下都把Humongous Region作为老年代的一部分来看待。

G1中的新生代和老年代的概念，都变成了一系列区域的动态集合，而不是固定区域，G1将Region作为每次回收的最小单位。G1会去跟踪各个Region里面的垃圾堆积的“价值”大小，即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，并根据用户设定的停顿时间（-XX:MaxGCPauseMills）来优先处理回收价值最大的那些Region。

![image-20200305232848498](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200305232848498.png)

G1的垃圾收集流程大致可以分为以下四个步骤：

- 初始标记：仅仅标记GC Roots能**直接关联**到的对象，并且修改TAMS的指针，让下一阶段用户线程并发时能正确地分配新对象；停顿线程但耗时很短，且是借用在Minor GC的时候同步完成
- 并发标记：对堆中的对象进行可达性分析，与用户进程并发执行；扫描完之后重新处理SATB记录下的**发生引用变动的对象**
- 最终标记：对用户线程做一个短暂的暂停，用于处理并发阶段后仍遗留下来的少量的SATB记录
- 筛选回收：对各个Region的回收价值和成本进行排序，根据用户期望的停顿时间来制定计划，把选择进行回收的Region中的存活对象**移动**到空的Region中，在清理掉旧的Region中的全部空间。涉及到移动操作，必须暂停用户线程，由多条线程并行处理

综上所述，G1并不一味追求低延迟，而是**在延迟可控的情况下获得尽可能高的吞吐量**。从G1开始的收集器都开始追求应付内存分配速率，不追求一次性把整个Java堆清理干净，只要收集速度跟得上对象分配速度就行了。

G1从**整体**看是基于标记-整理的，但从**局部**（两个Region之间）来看又是基于标记-复制，这意味着**G1不会产生内存碎片**，利于程序的长时间运行。

G1也有一些弱项：

- 由于G1用于处理**跨代指针**的卡表较为复杂，因而G1为了垃圾收集而产生的**内存占用**较大
- G1的**写屏障**较为复杂，实现为类似消息队列的结构，把写前屏障和写后屏障中要做的事放入队列，再进行异步处理，因而G1程序运行时的**额外执行负载**比CMS高

#### 关于G1的细节部分

1. 跨Region引用对象：每个Region都维护有自己的记忆集，它们会记录下别的Region指向自己的指针并标记这些指针分别在哪些卡页的范围之内。G1的记忆集本质是是哈希表，key是别的Region的起始地址，value是一个集合，存储的是卡表的索引号。这种**双向卡表**更复杂，至少耗费10%至20%的Java堆内存。
2. 并发阶段保证收集线程和用户线程互不干扰：通过**原始快照（SATB）**实现当用户线程改变对象引用关系时，原本的对象图结构不变，使得标记结果正确。此外，每个Region都有两个名为**TAMS**的指针，把Region中的一部分空间划分出来用于并发过程中新对象的分配；这些新对象的地址都必须在这两个指针上，都默认是**存活**。
3. 建立可靠的停顿预测模型：以**衰减平均值**为理论基础实现。在垃圾收集过程中，G1会记录每个Region的回收耗时，每个Region记忆集中脏卡的数量等可测量的步骤花费的成本，并分析得到统计信息。衰减平均值比普通平均值更容易受到**新数据**的影响，Region的统计状态越新越能决定其回收价值。

