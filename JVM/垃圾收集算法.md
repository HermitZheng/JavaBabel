# 垃圾收集算法

程序计数器、虚拟机栈、本地方法栈三个区域为**线程私有**的，每个栈帧中分配的内存基本在类结构确定时就是已知的，当方法结束或者线程结束时，内存自然就被回收了。

垃圾收集主要针对**Java堆**和**方法区**进行。

## 确定需要回收的对象

### 1. 引用计数算法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加一；当引用失效时，计数器的值就减一；任何时候计数器为零的对象就是不可能再被使用的。

但是单纯的引用计数算法很难解决两个对象之间相互循环引用的问题：当两个对象相互引用，除此之外没有任何其他引用时，实际上这两个对象以及不可能再被访问，但是引用计数都不为零，也就无法回收。 	

```java
public class ReferenceCountingGC {
	public Object instance = null;
	private static final int _1MB = 1024 * 1024;

	/**
 	* 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过
 	*/
	private byte[] bigSize = new byte[2 * _1MB];

	public static void testGC() {
    	ReferenceCountingGC objA = new ReferenceCountingGC();
    	ReferenceCountingGC objB = new ReferenceCountingGC();
    	objA.instance = objB;
    	objB.instance = objA;

    	objA = null;
    	objB = null;

    	// 假设在这行发生GC，objA和objB是否能被回收？
    	System.gc();
	}
}
```
结果是两个对象都被回收了：**Java虚拟机并没有使用引用计数算法。**



### 2. 可达性分析算法

通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点出发根据引用关系向下搜索，搜索过程所走过的路程称为“引用链”；如果一个对象到根节点之间没有任何引用链相连，或者说不可达时，此对象就是不可能再被使用的。

![image-20200303174017723](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200303174017723.png)

固定可作为GC Roots的对象包括以下几种：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象：

  譬如各个线程被调用的方法堆栈中的参数、局部变量等

- 在方法区中类静态属性引用的对象

  譬如Java类的引用类型静态变量

- 在方法区中常量引用的对象

  譬如字符串常量池里的引用

- 在本地方法栈中JNI引用的对象

- Java虚拟机内部的引用

  如基本类型对应的Class对象、一些常驻的异常对象、系统类加载器

  

### 3. 回收方法区

方法区存放的永久代对象回收条件苛刻，回收的性价比也较低。

方法区的垃圾收集主要针对两部分内容：**废弃的常量**和**不再使用的类型**

判断一个类型是否不再被使用：

- 该类的所有实例都已经被回收，堆中不存在任何该类及其子类的实例
- 加载该类的类加载器已经被回收
- 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

满足以上条件的无用类“允许”被回收，可以通过-Xnoclassgc参数控制是否回收

在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常需要Java虚拟机具备类型卸载的功能，以保证不会对方法区造成过大的内存压力。



### 4. finalize()

当一个对象将被回收时，假如对象的finalize()方法**没有被覆盖**，或者**已经被虚拟机调用过**，则将其回收。

反之，虚拟机将会执行finalize()方法，如果对象通过finalize()方法重新与引用链上的任何一个对象建立关系，那么对象就完成了“自救“，不会被回收。

这个方法类似于C++的析构函数，用于“关闭外部资源”，但是因为它运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因而**不推荐使用**。使用try-finally或者其它方式可以做的更好、更及时。



## 引用类型

无论是引用计数算法判断引用数量，还是可达性分析算法判断对象的引用链是否可达，判断对象是否存活都和“引用”离不开关系。

Java提供了四种不同强度的引用类型：

### 1. 强引用（Strongly Reference）

最传统的引用的定义，指在程序代码中普遍存在的引用赋值

```java
Object obj = new Object();
```

只要强引用关系还存在，垃圾收集器就**永远不会**回收掉被引用的对象。



### 2. 软引用（Soft Reference）

用于描述一些还有用，但非必须的对象。

```java
Object obj = new Object();
SoftReference<Object> soft = new SoftReference<>(obj);
obj = null; // obj只被软引用关联
```

被软引用关联着的对象，在系统**将要发生内存溢出异常前**，会把这些对象列进回收范围内进行二次回收，如果这次回收还没有足够内存，才会抛出内存溢出异常。



### 3. 弱引用（Weak Reference）

也是描述一些非必须对象，但是强度比软引用低一些。

```java
Object obj = new Object();
WeakReference<Object> weak = new WeakReference<>(obj);
obj = null;
```

当垃圾收集器开始工作时，无论内存是否足够，都会回收掉被弱引用关联的对象。



### 4. 虚引用（Phantom Reference）

也被称为幽灵引用或者幻影引用，是最弱的引用关系。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```

一个对象是否有虚引用的存在，对于其生存时间完全没有影响，也无法通过虚引用得到对象的实例；虚引用唯一的作业是当对象被收集器回收时，能够收到一个系统通知。



## 垃圾收集算法

### 分代收集理论

分代假说：

1. 弱分代假说：绝大多数对象都是自生自灭的
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数

记忆集：

依据跨代引用假说，我们就不应再为少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每个对象是否存在跨代引用；只需在新生代上建立一个全局的数据结构，被称为**”记忆集“**（Remember Set），这个结构把老年代划分为若干个小块，并标识出老年代中的哪些区域会被跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存才会被加入到GC Roots中进行扫描。



### 1. 标记-清除算法

首先标记出需要回收的对象，在标记完成后，统一回收掉所有被标记的对象；或者标记存活对象，并回收未标记对象。

它有两个主要缺点：

1. 执行效率不稳定：如果Java堆中包含大量对象，且大多数都是要被回收的，就必须进行大量的标记和清除操作，执行效率随着对象数量增长而降低。
2. 内存空间碎片化问题：产生大量不连续的内存碎片，影响后续的内存分配。



### 2. 标记-复制算法

半区复制：将可用内存按照容量分成大小相等的两块，当一块内存使用完时，就将还存活着的内存全部移到另一块，并把使用过的内存一次清理掉。

当多数对象存活时，会产生很大的复制开销；当多数对象被回收时，复制的开销较小，而且在之后分配内存时也不会有空间碎片的问题，只要移动栈顶指针，按顺序分配即可。

不足之处是**可使用内存缩小为了原来的一半**；因为一般新生代对象90%以上熬不过第一轮收集，因此不需要对半分，从而有一种优化策略称为“Appel”式回收。

把新生代区域划分为一块较大的Eden区（80%）和两块Survivor区（2*10%），每次只使用Eden和一块Survivor。当发生垃圾收集时，将存活的对象全部移动到另一块Survivor中，接着直接清空Eden和已用过的Survivor。

“Appel”式回收还有一个安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就依赖其他区域（大多是老年代）进行分配担保。



### 3. 标记-整理算法

标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率会降低，所以老年代不能使用这种算法。

将对象标记后，所有存活对象都向内存空间的一段移动，然后直接清理掉边界以外的内存。

优点：不会产生内存碎片（影响到吞吐量）

缺点：移动存活对象并更新引用会降低效率，且进行这个操作时需要全部暂停应用程序（影响程序延迟）

综合考虑，对产生的内存碎片进行整理的开销仍然大于移动对象。整理算法综合效率较高。

还有一种“和稀泥式”解决方案，让虚拟机在平时使用清除算法，当内存的碎片化程度大到影响内存分配时，再使用整理算法进行一次收集。