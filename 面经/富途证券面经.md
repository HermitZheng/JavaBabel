# 富途证券面经收集

1. 性能优化？



2. 代码对错：https://www.nowcoder.com/discuss/423216?type=post&order=time&pos=&page=1&channel=&source_id=1



3. 智力题：https://www.nowcoder.com/discuss/414594



## 面向对象、设计模式

1. 面向对象三个特征，每个详细说一下。

- 封装：把对象抽象成一个类，选择性的对类的数据、方法等属性进行隐藏或公开，并提供一些public的入口来对类进行访问或使用

- 继承：在不对原有类进行改动的情况下，让子类继承父类，来对父类的属性和方法进行改动或者功能进行扩展

- 多态：一个方法在不同的类中、或者在不同的输入情况下，可以有不同的实现

  - 重写：@Override。子类对于继承自父类的方法，可以改变其具体实现，但是**返回值**和**形参**（参数列表）不能改变。

    访问权限必须更大public (子类)> protected（父类），不能继承则不能重写

  - 重载：一个方法在一个类中，方法名不变，对于不同的输入（形参、参数列表），可以有不同的具体实现，返回值和返回类型可以更改（访问权限可以不同）

  



2. 设计模式的五大原则



3. 平时用到的设计模式？这里列举了七八个，还不满足，继续追问。

   单例、工厂、原型、建造者

   代理、装饰器、适配器

   责任链、观察者、模板、策略

   

   

4. 说一下单例模式，什么场景使用？单例模式有什么缺点，会造成什么问题？

   单例能够节省频繁的创建销毁实例的开销，也减轻了GC的压力

   只有一份实例的单例，能够保有一个缓存（比如一个Map存有一些信息，所有人都能从同一个单例的缓存中获取信息）

   饿汉的单例不能节省资源，但是线程安全；懒汉节省资源，但是不线程安全；懒汉的双重检查写法可以保证线程安全

   静态内部类、枚举的实现更好，枚举也可以防止反射攻击和序列化攻击



5. 说一下策略模式？有什么缺点？



6. 了解过、用过哪些？描述一下你是怎样用的，设计模式（我说了我比较熟的，单例、观察者、适配器、装饰器等，说了自己只是会写，知道原理，没有在项目中实际运用过）；



7. 设计模式的原则



## 操作系统

1. 线程和进程的区别，结合堆和栈说一下你的理解，线程的堆和栈是公有的还是私有的，一个进程中某个线程死了，其它线程会怎么样
   - 进程是一个独立的程序的一次运行活动，是系统进行**资源分配**的基本单位；线程是轻量级的进程，是一个基本的CPU执行单元，是系统**CPU独立调度**的基本单位，是进程中的实际运作单位。
   - 线程不拥有系统资源，只拥有一些运行必备的资源（程序计数器、虚拟机栈、本地方法栈）；线程之间可以共享所属进程的资源（堆、方法区、运行时常量池）
   - 进程是为了更好的使多道程序并发执行，提高系统的资源利用率和吞吐量；线程是为了减少程序在并发执行时的开销，提高系统的并发能力
   - 线程有自己的栈和局部变量，但是**没有单独的地址空间**，因而一个线程死亡后，整个进程以及所属线程都会死亡。一个进程崩溃后，不一定会对其他进程产生影响



2. 死锁产生的条件，怎么解决死锁的问题？

   - 条件：

     - 互斥条件：资源只能被一个进程占有
     - 请求与保持条件：一个进程在请求一个资源的同时，仍然占有自己的某个资源
     - 不剥夺条件：进程已获得的资源，在使用完之前，不允许被其他进程抢占
     - 循环等待条件：多个进程在占有资源的同时，请求其他进程占有的资源，循环等待

   - 破坏死锁：

     - 破坏互斥：不可破坏，临界资源本就是让他互斥访问的
     - 破坏请求与保持：进程一次性申请所有需要的资源
     - 破坏不剥夺：占用资源的进程如果申请不到需要的资源，就主动释放所持有的资源
     - 破坏循环等待：按序申请资源，释放资源时反序释放

   - 预防死锁：

     - 安全状态：找到一个分配资源的序列，是的所有进程都能正确的请求并释放资源，完成运行
     - 银行家算法：采用预分配策略检查分配完成时系统是否处于安全状态。

     



3. 线程、进程之间通信（操作系统）

   - 进程通信：多个进程之间相互通信，交换信息

     - 管道（无名管道）：半双工，有**亲缘**关系的父子进程之间通信
     - 有名管道：半双工，允许**无亲缘**关系的进程之间通信
     - 报文、消息队列：消息的链表。消息队列克服了信号承载**信息量少**，管道只能承载**无格式字节流**以及**缓冲区大小受限**等缺点。
     - 信号
     - 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。用于锁机制，及线程同步
     - 套接字：可用于不同机器之间的通信

   - 线程通信：主要用于线程同步，而非数据交换

     - 锁机制：
       - 互斥锁：同一时间只有一个线程占有资源，其他线程进入阻塞状态
       - 读写锁：多个线程可以同时读共享数据，但是对写是互斥的（在读时不允许写，在写时读写都不允许）
       - 条件变量（条件锁）：可以以原子的方式**阻塞**线程，**直到某个特定条件为真为止**。对条件的测试是在互斥锁的保护下进行的。条件变量始终**与互斥锁一起使用**。它解决的问题不是「互斥」，而是「等待」。
       - 自旋锁：上锁受阻的线程不阻塞，而是循环轮询查看是否能获得锁，没有线程切换开销，但是会浪费CPU资源。适用于多个处理器，或者不希望产生线程切换开销。
     - 信号量：对公共资源进行计数，资源只能被若干个线程占有并进行计数。只能访问信号量大于0的资源
     - 信号

     

4. 线程之间通信（JAVA）

   - 锁与同步

   - 等待、通知机制：wait(), notify(), notifyAll()

     - notify()：随机唤醒一个等待的线程
     - wait()：只能在同步方法或代码块中使用

   - 信号量：可通过volatile实现

   - 管道：线程之间按顺序进行读写

     ```java
      		PipedWriter writer = new PipedWriter();
             PipedReader reader = new PipedReader();
             writer.connect(reader); // 这里注意一定要连接，才能通信
             new Thread(new ReaderThread(reader)).start();
             Thread.sleep(1000);
             new Thread(new WriterThread(writer)).start();
     ```

   - join()方法：让当前线程陷入“等待”状态，等join的这个线程执行完成后，再继续执行当前线程。join底层调用的都是wait方法，也可以指定时间

   - sleep()方法：**sleep方法是不会释放当前的锁的（只释放cpu资源），而wait方法会。**sleep必须指定时间。sleep可以在任意位置。

   - ThreadLocal类：它为每个线程都创建一个**副本**，每个线程可以访问自己内部的副本变量。（线程本地变量）

   - InheritableThreadLocal：（继承）**子线程**也可以存取副本值



5. *计算机的内存区域
   - 一个主内存（共享主内存）
   - 每个CPU各自拥有高速缓存（缓存一致性）



6. 



8. **两个进程对同一个变量自增10次（多线程打印！！！）**，结果如何？

   res最小值为2，最大值为20





## 计算机网络

1. 介绍一下**HTTPS**（加密过程？），和**http**的区别：Http + SSL

   **为什么对称加密是高效的？公钥和私钥的长度？**

   对称加密双方共用同一个密钥。加密解密的速度快。

   - 双方使用**非对称加密**得到共有的密钥

   - 客户端：随机数1、支持的哈希算法、SSL协议版本 ——> 服务端
   - 服务端：确认双方的加密算法、SSL版本，随机数2、CA证书——> 客户端
   - 客户端：验证CA证书有效性，使用其中的Hash算法生成随机数3，使用公钥加密随机数3——>服务端
   - 服务端：使用私钥解密随机数3
   - 双方通知握手完毕，此后使用随机数组成的密钥进行**对称加密**
   - 对称加密的密钥长度为1024bit (128byte)



2. OSI七层模型、TCP/IP四层模型、五层模型，每一层的常见协议





3. TCP三次握手/四次挥手，问了一下细节，TCP首部

   



4. TCP/UDP区别、TCP拥塞控制、流量控制

   - 流量控制是接收方的要求，拥塞控制是发送方自觉行为，都是为了控制注入网络的数据量
   - 两种控制都会设置一个**发送窗口**，最终发送窗口的上限为两个窗口的```Min{rwnd, cwnd}```

   - 流量控制：滑动窗口，双方进行确认发送发能够发送的报文段数量，即窗口值。发送方使用seq字段来记录发送的报文序号，接收方用ack字段来响应接收。如果一部分报文丢失，接收方会等待发送方超时重传并接收到之后，再发送ack响应。
   - **持续计数器**：发送方一旦受到接收方的**零窗口**通知，就启动计数器，如果计数器到期还没收到新的通知，就发送携带1字节的探测报文来确认窗口值，如果窗口值仍为零则重置计数器。以此打破**死锁**。
   - 拥塞控制：
     - 慢开始：从小到大逐渐增大拥塞窗口的值，用于试探网络的负载能力，一般初始值为2-4，接收到一个确认就+1，之后每完成一个轮次窗口值就**加倍**（**指数**增长速度快）
     - 拥塞避免：**门槛值**ssthresh，如果窗口值大于门槛值，则进入拥塞避免阶段，增长速度受到限制，增长速度变成线性（+1）
     - 快重传：当发送发连续收到三个重复确认时，接收方确实没有接收到报文，此时应该**尽快重传**，这样就不会发生超时，因而发送方也不会认为网络发生了拥塞。
     - 快恢复：当一个报文**超时**，则认为网络发生拥塞。立即将拥塞窗口设置为原来的**一半**，同时将门槛值也设置为这个数值，因此将立即进入**拥塞避免**阶段。（拥塞窗口波动较小）

   

5. TCP和UDP的联系和区别，优劣，应用场景；现在视频面试用的是TCP还是UDP

- TCP 是**面向连接**的，并且是一种**可靠**的协议，在基于 TCP 进行通信时，通信双方需要先建立一个 TCP 连接，**建立连接**需要经过三次握手，握手成功才可以进行通信

  1、基于连接的，可靠性高

  2、有连接过程（3次握手过程），会有**延时**，**实时性较差**，

  3、传输相同的数据时，TCP**首部**开销20字节;UDP的首部开销小，只有8个字节，TCP报头比UDP复杂，故**实际包含的用户数据较少**。TCP无丢包，而UDP有丢包，故TCP的开销大，UDP开销较小。

  4、每一条TCP连接只能是**点到点**的；UDP支持一对一，一对多，多对一和多对多的交互通信

- 是一种面向无连接，且不可靠的协议，在通信过程中，它并不像 TCP 那样需要先建立一个连接，只要（目的地址，端口号，源地址，端口号）确定了，就可以直接发送信息报文，并且不需要确保服务端一定能收到或收到完整的数据。它仅仅提供了**校验和**机制来保障一个报文是否完整，若校验失败，则直接丢弃报文，不做任何处理。

- TCP：SMTP电子邮件、TELNET远程连接、HTTP互联网、FTP文件传输

- UDP：DNS域名解析、TFTP文件传输、RIP路由选择协议、DHCP IP地址配置、NFS远程文件服务器

- 在线视频使用的是UDP



6. HTTP版本号，状态码
   - 状态码：
     - 1XX 信息响应：100临时响应
     - 2XX成功响应：200请求成功、202已接受还未响应
     - 3XX重定向：301请求的资源已被永久地移动
     - 4XX客户端响应：400语义、参数有误，403服务器拒绝执行，404找不到请求的资源
     - 5XX服务端响应：500未知错误，502网关错误
   - 版本号：
     - 1.0短连接：无法复用，
     - 1.1长连接：默认使用带流水线的持久连接，一个TCP连接可以传送多个Http请求和响应。1.1增加了更多的请求头和响应头来扩展功能
     - 2.0：多路复用，二进制分帧（与http和tcp udp之间）在不改变1.x的语义方法请求头的前提下提高性能，首部压缩，服务端可以对客户端的一个请求发送多个响应（服务端推送）



7. IP协议位于哪一层

   网络层



8. 平时使用软件的过程中，哪些地方用到了TCP，UDP，视频聊天为什么使用UDP,除了传输速度快还有什么原因，发消息是使用TCP还是UDP
   - 对于图像、声音这种对**可靠性**要求不那么高的使用UDP，对于文本、程序、文件这种要求可靠性使用TCP





9. **输入网址按回车后发生什么，DNS的方式。**
   - 浏览器缓存、hosts文件映射、**本地**DNS解析器缓存（校园网、小区。。。）
   - 根域名服务器查询（返回ip或者顶级域名服务器）、顶级域名服务器查询
   - 主机向本地域名服务器的查询一般使用**递归**
   - 本地域名服务器向根域名服务器的查询一般使用**迭代**

- 输入网址后
  - DNS域名解析；
  - 建立TCP连接；
  - 发送HTTP请求；
  - 服务器处理请求；
  - 返回响应结果；
  - 关闭TCP连接；
  - 浏览器解析HTML；
  - 浏览器布局渲染；



## 数据结构

1. 数组和链表区别，链表和树的联系，树和图的区别，数组的内存分配





2. 什么是二叉树/二叉搜索树？**二叉搜索树的搜索时间复杂度为多少？最差最好情况下呢？**

   O(logN) 近似于二分；O(N) 退化为链表



3. 判断单向链表是否有环

   快慢指针，set



4. ArrayList 和 LinkedList 的区别是什么？





5. 栈和队列的区别是什么？



6. list、set、map 的区别是什么？



7. 什么是完全二叉树；平衡二叉树，如何保持二叉树的平衡性



8. 手写红黑树？



9. BST树的插入代码；



## Java

1. 访问控制（简述 private、protected（同一个包非继承？）、public 的区别？）

- 访问修饰符
  - public：所有都能访问
  - default：当前包内访问
  - protected：当前包内、以及该类的子类都能访问
  - private：当前类内部访问



2. 讲讲**多线程通信**了解什么
   - 锁（互斥锁、读写锁、条件锁、自旋锁）
   - 管道：PipedReader、PipedInputStream、。。。。
   - 信号量：Semaphore类。。
   - wait、notify、sleep、join、yield。。。
   - volatile、synchronized
   - ThreadLocal、InheritableThreadLocal



3. 线程安全是什么

   当多个线程对同一个共享变量进行写操作时可能会产生的数据冲突问题，但是做读操作是不会发生数据冲突问题。解决方法：

   - 使用内部锁synchronized，可以使用同步代码块，如果是实例方法可用this作为锁对象，如果是静态方法，可以用类.class作为锁，或者使用同步方法底层和同步代码块一样，如果是实例方法默认用this作为锁，如果是静态方法默认使用类.class。
   - 使用java.util.concurrent包中的锁，例如ReentrantLock。



4. synchronized、volatile区别

- volatile：
  - 保证被修饰变量的可见性，即一个线程修改变量后，其他线程都会获取到最新的变量值（各自的工作内存中的变量副本失效，需要从主存中获取最新值）
  - 防止指令重排（不管如何排序，要保证单线程下执行完毕后结果相同）
  - happens-before：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。
  - 不会执行加锁操作，不会导致线程阻塞，多个线程都可对变量进行赋值或读取
  - 保证变量**单次读写的原子性**，但不能保证i++这种的原子性，因为本质是是读+写
  - 会不断地去从总线上进行嗅探，来确认变量副本是否失效，占用总线带宽，因而不要大量使用volatile
- synchronized：
  - 用于为Java对象、方法、代码块提供线程安全的操作，属于排它的悲观锁，也属于可重入锁。
  - 被synchronized修饰的方法和代码块在同一时刻只能有一个线程访问，其他线程只有等待当前线程释放锁资源后才能访问。
  - Java中的每个对象都有一个monitor监视器对象，加锁就是在竞争monitor，对代码块加锁是通过在前后分别加上monitorenter和monitorexit指令实现的，对方是否加锁是通过一个标记位来判断的。
- 区别：
  - volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。
  - volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全)；而synchronized是一种排他(互斥)的机制。
  -  volatile用于禁止指令重排序：可以解决单例双重检查对象初始化代码执行乱序问题。
  - volatile可以看做是轻量版的synchronized，volatile不保证原子性，但是如果是对一个共享变量进行多个线程的赋值，而没有其他的操作，那么就可以用volatile来代替synchronized，因为赋值本身是有原子性的，而volatile又保证了可见性，所以就可以保证线程安全了。



5. java集合类，map和set的区别





6. char,int,int在内存中多大，有一个字符串，“abcde”,内存占用空间是多少？

   - boolean：1位
   - byte：1字节
   - char：2字节
   - short：2字节
   - int：4字节
   - float：4字节
   - double：8字节
   - long：8字节

   - String：底层是char数组，即2*n字节（对象实际占用40 + 2*n）
   - 对象头（8 字节）+ 引用 (4 字节 ) + char 数组（16 字节）+ 1个 int hash（4字节）+ 1个long uuid（8字节）= 40 字节。



7. Java关键字，说了修饰符，还有static、**final**
   - static：只能修饰变量、方法和**代码块**，不能修饰类（可以修饰**静态内部类**），被修饰的方法可以通过类名直接访问。静态变量和静态方法独立于该类的任何对象，也就是说，它不依赖类特定的实例，**被类的所有实例所共享**。静态方法不会被子类覆盖！！
   - static：**类加载**时JVM会把它放到**方法区**，被本类以及本类中所有实例所**公用**。在编译后所分配的内存会在一直存在，直到程序退出内存才会释放这个空间。
   - final：可以修饰类、变量、方法。被修饰的类不可继承，被修饰的变量在赋值之后不能改变值，变量引用不能更改，但是**引用内容可以更改**（如Person p.setAge(int)），被修饰的方法不可被重写。



8. java 的 double 类型，能否准确存储 0.3 这个值？0.5呢（IEEE754标准）

   都不能精确存储：0.5-0.4 = 0.099999；0.3-0.1 = 0.19999999；0.3-0.2 = 0.0999999

   在十进制中小数有些是无法完整用二进制表示的。所以只能用**有限位**来表示，从而在存储时可能就会有误差。对于十进制的小数转换成二进制采用乘2取整法进行计算，取掉整数部分后，剩下的小数继续乘以2,直到小数部分全为0。

   数字存储超过一定大小就会失真，十六位存储包含符号位、指数位，实际存储的位数也是有限的



9. 【静态内部类】跟【非静态内部类】有什么区别？

   - 内部类：可以使用各种访问修饰符，以及abstract、static、final等，也可以实现特定的接口。外部类按常规的类访问方式使用内部类，唯一的差别是外部类可以访问内部类的**所有方法与属性**，包括**私有**方法与属性。**只有内部类能被static修饰。**

   - 静态内部类：与外层类绑定，即使外层类没有实例化对象，静态内部类依然存在。静态内部类可以定义静态方法，外部类想要可以通过静态内部类直接访问静态方法，而普通方法需要创建对象实例。**静态内部类只能访问外部类的静态成员。**
   - 非静态内部类：非静态内部类在定义成员变量或者成员方法的时候，是不能够被定义成静态的。**非静态内部类可以访问外部类的所有成员。**

   ```java
   // 假设类A有{静态内部类B}和{非静态内部类C}，创建B和C的区别为：
   A a=new A(); 
   A.B b=new A.B(); 
   A.C c=a.new C();
   ```

   

10. String s0 = "abc";String s1 = "abc";String s2 = new String("abc");问的什么不用说了吧；

    ```s0 == s1 ; s1 != s2```



11. 描述下 HashMap 实现，是否线程安全

    HashMap是由数组+链表（红黑树）组成的，数组中的每一个位置都是一个Entry（Node），是它的内部类

    ```java
    static class Node<K, V> implements Map.Entry<K, V> {
        final int hash;
        final K key;
        V value;
        Node<K, V> next;
        ......
    }
    ```

- 新的Entry在插入链表时是如何插入的？8之前是头插法，8之后是**尾插法**。
- 为什么是尾插法，区别？有关HashMap的**扩容**Resize机制（HashMap的**默认初始长度为16**：1<<4）
  - 有两个因素：Capacity：Hashmap当前长度； LoadFactory：**负载因子**：默认0.75f
  - 例如：当前容量为100，则装入第76>75个元素时，就需要进行扩容
  - 扩容的步骤：
    - 创建一个新的Entry空数组，长度是原数组的两倍
    - **ReHash**：遍历原数组，将每一个Entry重新ReHash到新数组（因为计算的hash值和整个数组的长度有关，因此需要重新计算）```index = HashCode(Key) & (Length - 1)```
  - 头插法？例如：在容量为2的数组中，不同线程插入A、B、C，如果没有resize即A->B->C（A为头部）
    - 在扩容并进行Rehash后，可能C会到数组其他位置，而A和B变成了B->A
    - 由于进行Rehash时会遍历原链表，而对于新数组，新插入的Entry使用头插法，即B->A（B为头部）
    - 此时A和B可能形成环形链表，如果去取值就会发生Infinite Loop。
  - 如果使用尾插法，链表元素即使经过了Resize也会**保持原有的顺序**，即A->B，就不会出现环形链表





12. Java用过哪些Collections类







13. Java中==和equals()的区别；两个object， (obj1==obj2)==true那么obj1.equals(obj2)==?，反之呢？；equals()和Object的hashcode有什么关系

- “==”：对于基本类型，比较的是值；对于引用类型，比较的是引用是否相同
- equals：本质也是”==“，但是一些类比如String进行了重写，变成了值比较。
- ==相同，equals也相同；反之不一定，可能值相等但是引用不相等
- 关于hashcode：hashcode默认返回对象的**内存地址值**，也可以进行重写。两个对象使用`x.equals(y)`判断结果为`true`时，两个对象的`hashCode`不一定相同。
- equals和hashcode应该一起重写：如果两个对象equals，那么它们的hashCode必然相等；但是hashCode相等，equals不一定相等。
- HashMap：先计算hashcode得到在哈希表中的索引，之后将待插入元素和表中的元素使用equals对比，来判断是否进行插入



14. Java中的锁。
    - Java中的锁主要用于保障多并发情况下数据的一致性，线程必须先获取锁才能进行操作，可以保证数据的安全。
    - 从乐观和悲观的角度可以分为乐观锁和悲观锁。
      - 乐观锁通常使用CAS操作
    - 从获取资源的公平性可以分为公平锁和非公平锁。
      - 公平锁指在分配锁前检查是否有线程在排队等待获取该锁，优先将锁分配给**排队时间最长的线程**。
      - 非公平锁指在分配锁时不考虑线程排队等待的情况，**直接尝试获取锁**，获取不到锁就在排到队尾等待。
      - 因为公平锁需要在多核情况下**维护一个锁线程等待队列**，基于该队列进行锁的分配，因此效率比非公平锁低很多。synchronized是非公平锁
    - 从是否共享资源的角度可以分为共享锁和排它锁。
      - 共享锁：允许多个线程同时获取该锁，并发访问共享资源，ReentrantReadWriteLock的读锁为共享锁的实现。
      - 排它锁：也叫互斥锁 ，每次只允许有一个线程独占该锁，ReentrantLock为排它锁的实现。
      - 排它锁是一种**悲观**的加锁策略，同一时刻只允许**一个线程**读取锁资源，限制了读操作的并发性，因为并发读线程并不会影响数据的一致性，因此共享锁采用了乐观的加锁策略，允许多个执行读操作的线程同时访问共享资源。
    - 从锁的状态角度可分为偏向锁、轻量级锁和重量级锁。同时在JVM中还设计了自旋锁以更快地使用CPU资源。
      - 偏向锁：检查锁对象头部信息记录的线程ID是否为本线程，如果是的话不进行加锁解锁操作，提高效率；如果ID不为本线程，尝试修改，同时锁升级
      - 轻量级锁：通知之前的线程**暂停**，两个线程通过CAS操作来竞争锁；成功的线程获得资源，失败的进入**自旋**。在自旋过程中，如果成功获取到了锁资源（之前的线程执行完毕释放资源），则自旋成功，仍然为轻量级锁；如果自旋失败，则锁升级
      - 重量级锁：自旋的线程进入阻塞，等待之前的线程执行结束并唤醒自己
      - 锁降级：Stop the World阶段，如果JVM发现有空闲的锁，则对其进行降级



15. String,StringBuffer, StringbBuilder的区别，StringBuffer为什么线程安全。String可以被继承吗
    - 都是**final**类，都不允许被继承；
    - String类长度是不可变的，StringBuffer和StringBuilder类长度是可以改变的；
    - StringBuffer类是线程安全的，StringBuilder不是线程安全的；
    - StringBuffer的方法被synchronized修饰



16. 说一下对原子性的理解。

    原子性是指**一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉**。

    [java内存模型](https://www.jianshu.com/p/d52fea0d6ba5)中定义了8中操作都是原子的，不可再分的。

    - lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；

    - unlock(解锁):作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定

    - read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的load动作使用；

    - load（载入）：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本

    - use（使用）：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；

    - assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；

    - store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用；

    - write（操作）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
    - **大致认为基本数据类型的访问读写具备原子性**（例外就是**long**和**double**的非原子性协定）



17. **谈谈Java语言的特性**





18. JDK8的接口？
    - default方法：实现类**可以选择不实现**这个方法。接口通过声明默认方法，提供了这个方法的默认实现。**如果子类实现了这个方法调用时使用子类的实现，否则使用默认实现。**
    - 如果两个接口中定义了一模一样的默认方法，并且一个**实现类同时实现了这两个接口**，那么**必须**在实现类中**重写**默认方法，否则编译失败。
    - static方法：静态方法必须有实现。但是**实现此接口的类无法实现静态方法**，不可以通过实现类的类名或者实现类的对象调用。如果有两个接口中都实现了相同的静态方法，那么并不会发生错误，因为能通过**接口名**进行区分。



19. happens-before?

happens-before关系的定义如下：

1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
2. **两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。**



20. Java内存模型

- JMM是**抽象**的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。

- **线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取**。
- **JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证**。



21. Hashtable和HashMap的区别。HashMap和Hashtable的实现原理。Hashtable怎么实现线程安全。





22. ConCurrentHashMap的原理。为什么不用Hashtable。







## JVM

1. JVM内存结构，栈/堆区别
   - 共享数据区域：堆、方法区、运行时常量池
   - 线程私有区域：程序计数器、虚拟机栈、本地方法栈
   - 堆：主要是**对象实例**
   - 栈：**局部变量表**、操作数栈、**对象引用**、方法出口、动态链接
   - 方法区：**类信息、常量、静态变量**、*即时编译器编译的代码
   - 运行时常量池：方法区的一部分，Class文件除了各种描述信息外，还有一个**常量池表**，存放了编译期生成的各种**字面量**和**符号引用**，这部分信息在**类加载后**存放到方法区的运行时常量池中。注意：常量不一定在编译期生成，也可以动态生成。



3. JVM中怎么判断对象需要回收，垃圾回收算法，什么时候垃圾回收。

- 引用计数器：（Java不使用）
  - 优点：判断效率高，实现简单
  - 缺点：无法解决对象之间循环引用的问题
- 可达性分析算法：
  - GC Roots：虚拟机栈中的引用对象，方法区中的静态变量和常量引用的对象，本地方法栈中JNI引用对象
  - 通过一系列称为 "GC Roots" 的对象作为起始点，从这个节点向下搜索，搜索走过的路径就是
  - ，当一个对象到 GC Roots 没有任何引用链相连，也就是从 GC Roots 到这个对象不可达，则这个对象不可达，可以被回收。



4. 内存泄漏？如何解决、避免内存泄漏？

- 不再会被使用的对象的内存不能被回收，就是内存泄露。
- **如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露**

```java
    Object object; 	// 应该改为局部变量而非全局变量（尽量减小作用域）
    public void method1(){
        object = new Object();
        //...其他代码
        object = null;		// 手动赋值为null来促使回收
    }
```



5. 垃圾回收算法，机制。程序计数器的缺点。可达性分析的优缺点。详细说一下分代回收。





6. 类加载机制描述一下，static类在类加载机制中的过程。



7. JVM内存对齐

   - java对象分为三部分：**对象头(**Object Header), **实例数据**(instance data)，**对齐填充**(padding)

   - 对象占用的内存为**8的倍数**，其中对象头占用8字节
   - char+int+int = 对象头8字节+2+4+4+6(对齐) = 24字节



## Android

1. Android自定view（我直接说不了解了...）

2. Android四大组件

3. Android Handler Lopper 相关

4. Android 数据存储有哪些形式



## 数据库

1. 数据库，一个公司想对18年3月-18年8月在公司工作的员工做出补偿，现有员工信息表记录了姓名、入职时间和离职时间，找出需要被补偿的人

   select  name  from  employee  where  entry_date between '2018-03-01' and '2018-08-01'  
   
   or quit_date between '2018-03-01' and '2018-08-01' 
   
   or (entry_date < '2018-03-01' and quit_date > '2018-08-01')



2. 两张表求发帖数量最高的前十个用户的id

   select * from user where user_id in (
   
   select top 10 user_id from content 
   
   group by user_id order by count(content_id) desc
   
   )



## 算法

1. 合并两个数组，使合并后的数组有序

   ```java
   public void merge(int[] A, int m, int[] B, int n) {	
       int i = m-1, j = n-1, k = m + n - 1;		// 从尾部开始归并
       while (i >=0 && j >=0) {
           if (A[i] < B[j]) A[k--] = B[j--];
           else A[k--] = A[i--];
       }
       while (j >= 0) A[k--] = B[j--];		// 只需要检查B，A数组剩余的可以不动
   }
   ```



2. **快排复杂度**，怎么实现的

   O(NLogN),最差O(N2)

   快排是**不稳定**的，指**两个相同的元素**经过排序后，**相对位置**可能和起始位置不同

各种排序的比较和应用场景：

- 数组较**短**时，使用**插排**和**选排**		
- 当元素**基本有序**时，使用**插排**、**冒泡（优化：提前退出，记录并减少外层循环）**、随机的快排
- 当长度较大，应该使用O(NLogN)的**快排、堆排、归并**
- 当待排序的关键字**随机分布**时，**快排**的平均时间最短
- **堆排序**所需的**辅助空间**少于快速排序，并且不会出现快速排序可能出现的最坏情况。
- 若要求排序**稳定**，则可选用归并排序。



3. 二叉树插入

   - 二叉搜索树：按大小进行比较，直到找到插入位置（null结点 -> new TreeNode(val)），return root

     递归```(root.left(right) = method(root.left, val))```；

     迭代```(while(p != null) parent = p(记录上一级); p = p.left(right));```



4. Leetcode121，股票交易

   ```int[][][] dp = int[len+1][max_k+1][2]```

   ```K``` 意为交易次数，具体来说，就是还能够**购买**的次数；当max_k > len / 2时，退化为无限次交易

   2 意为交易状态，即手中是否持有股票，1为持有，0为未持有

   ```java
   for (int k=0; k <= max_k; k++) {
       dp[1][k][1] = Integer.MIN_VALUE;	// 
       dp[0][k][1] = Integer.MIN_VALUE;
   }
   for (int i=1; i <= len; i++) {
       for (int k=0; k <= max_k; k++) {
           // 卖出时K不变，利润增加prices[i-1]
           dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i-1]);
           // 买入时交易次数K-1，利润减少prices[i-1]
           dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i-1]);
       }
   }
   return dp[len][max_k][0];
   ```





5. Leetcode946， 验证栈的弹出顺序

   使用栈进行模拟

   ```java
   Stack<Integer> stack = new Stack<>();
   ```





6. 选择题：给定会议室的可使用时间[start, end]和一系列会议的开始结束时间[[s0, e0], [s1, e1], ...]，问哪种方法可以使在可使用时间内安排最多场次的会议：

   （1）按开始时间排序

   （2）按结束时间排序（✔，贪心原则）

   （3）按会议长短排序

   （4）以上均不可行





7. 单链表节点删除（答完后引申了一下，只给指向当前节点的指针怎么删除该节点

   - 常规：``` pre.next = node.next```

   - 只给当前节点：当前节点的值替换为next的值，然后舍弃掉next，继承后面的链表

     ```java
     node.val = node.next.val;
     node.next = node.next.next;
     ```





7. 括号合法性问题（32、20

   ```java
   Stack<Character> stack = new Stack<>();
   for (char c: s.toCharArray()) {
       if (c == '(') stack.push(')');		// 反向输入括号，可以在之后直接匹配
       else if (c == '{') stack.push('}');
       else if (c == '[') stack.push(']');		
       else if (stack.isEmpty() || stack.pop() != c) return false;
   }
   return stack.isEmpty();
   ```





9. 动态规划问题，最大数组子序列之和

```java
        int[] dp = new int[len+1];
        int max = Integer.MIN_VALUE;
        for (int i=1; i<=len; i++) {	// dp选择当前位置元素本身，还是加上i-1位置的dp值
            dp[i] = Math.max(dp[i-1]+nums[i-1], nums[i-1]);	
            max = Math.max(max, dp[i]);
        }
```





10. 求数组中出现频率TOP K的元素

    ```java
    map.put(num, map.getOrDefault(num, 0) + 1);
    new PriorityQueue<>(Comparator.comparingInt(map::get));	// 按频率排序
    for (int num: map.keySet()){
        heap.add(num);
        if (heap.size() > k) heap.poll();	// 当堆中元素大于K时将最小频率的元素出堆
    }
    ```

    优化：当K的值较小时，此算法效率较高；当**K的值较大**时，可以考虑使**堆中保存频较小的元素**





11. a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]，把 a 数组的内容打乱

    ```java
    Random random = new Random();
    for (int i=0; i<nums.length; i++) {
        swap(nums, 0, random.nextInt(nums.length));
    }
    ```





12. "(( 23 - 98.22 ) * (24*6.34) + 2) + 123 + 76 / 4"，表达式包含：加、减、乘、除、小括号、数字、小数点、空格

    中间可能有空格，表达式肯定是合法的，无需判断合法性，计算结果，说了两种，问我还有别的方法吗？

    



13. 了解哪些排序算法；归并排序原理，复杂度，是否稳定；怎么判断排序算法稳定性；快排和归并的优劣和使用场景





14. Leetcode19（删除链表的倒数第N个节点，要求**for和while总共只能使用一次**），双指针+复制删除法，面试官提示我链表只有一个节点时程序会有问题，然后我检查了一下代码，发现其实没有问题

    ```java
        ListNode node = head, pre = node;
        if(head.next == null && n == 1) return null;	// 只有一个头结点，返回null
        int i=0;
    	// i < n时，前指针在移动；node.next != null时，前后指针一起移动
        while (i < n || node.next != null) {
            if (i++ < n) {	
                node = node.next;	// 如果前指针超出链表，表示删除的是头结点
                if (node == null) return head.next;
            } else {	// 前后指针一起移动
                node = node.next;
                pre = pre.next;
            }
        }	// 执行删除
        pre.next = pre.next.next;
        return head;
    ```



15. **判断一个链表含有环。怎么找到这个环的入口**

    ```java
    Set<ListNode> set;	// set存储结点引用
    ListNode slow = head, fast = head.next;	//快慢指针
    while (slow != fast) {
        if (fast == null || fast.next == null) return false;	// 到头还没碰到，无环
        fast = fast.next.next;	// 走两步
        slow = slow.next;
    }
    return true;
    ```

    

16. 后序遍历

```java
TreeNode p = root, visit = null;
while (!stack.isEmpty() || p != null) {
    if (p != null) {	// 找到左子树最底端
        stack.push(p);
        p = p.left;
    } else {
        p = stack.peek();
        // 右子树已访问，则当前p的左右子树都已访问，则add(p)
        if (p.right == null || p.right == visit) {
            stack.pop();	// 当左右子树都访问完，才pop
            res.add(p.val);
            visit = p;		// p设置为已访问
            p = null;
        } else {		// 只访问了左子树，下面访问右子树
            p = p.right;
        }
    }
}
```

​	



## 智力题

1. **实验室有100个瓶子，其中有一瓶装有慢性毒药（第3天发作)，另外99瓶装有蒸馏水。请问至少需要多少只小白鼠才能在3天内找出哪一瓶是慢性毒药？**

   2 ^ n > 100

   0010011 3



2. 用两球在100层楼中找出会破掉的临界值





3. 一对夫妻，有两个孩子，其中一个是女孩，另外一个是女孩的概率是多少？

   男男，男女，女男，女女—— 1/3

   P(A) = 3/4 至少有一个女孩的概率；P(AB) = 1/4两个都是女孩的概率

   P(A | B) = P(AB) / P(A) = 1/3



4. 一个 5L，一个 6L 的瓶子，如何得到 3L 水？

   5 0

   0 5

   4 6

   5 4

   3 6



5. 11L和7L的水桶，要求打出2L的水

   0 7 / 7 7 / 11 3/ 3 7 / 10 7/ 11 6 / 6 7 / 11 2



6. 怎样找出一个篮子里面最大和最小的鸡蛋，复杂度如何？

   



7. 一个气球三个人轮流射，每个人射中气球的概率是0.3，问这个气球被射中的概率是多大。

   1 - 0.7^3



8. 生孩子问题：村子里的人如果生不到男孩则一直生，直到拥有5个孩子就不再生。请问若干年后村子的男女比例 

   女孩数量期望：0 *1/2 + 1 *1/4 + 2 *1/8 + 3 *1/16 + 4 *1/32 + 5 *1/32 = 31/32

   男孩数量期望：1 *1/2 + 1 *1/4 + 1 *1/8 + 1 *1/16 + 1 *1/32 = 31/32

​	

9. 25人5条跑道，找出最快的三个人



## 其他问题

1. 平时怎么学习，看哪些博客，做的项目是学校要求的还是自己做的



2. 说一下专业成绩，那你觉得哪一门课学的最好



3. 对我们公司的了解？



4. 为什么会投递我们公司？



5. 你最有成就感的一件事



6. **大学是怎么过的**



# 面经

1. 介绍一下你自己

2. 面向对象的三大特征，多态？

3. 接口和抽象类。**抽象类继承具体类**，**接口多继承**

4. static修饰符。static代码块在什么时候执行？static变量什么时候初始化？

   - **执行顺序：静态变量、静态代码块——>变量——>构造代码块——>构造方法|类初始化完成|**
   - 注意：同级之间（静态变量、代码块）执行顺序取决于**代码顺序**

   对于**B extends A**的情况

   - A静态代码块——>B静态代码块
   - A构造代码块、构造器 ——> B构造代码块、构造器

   

5. 讲讲HashMap。哈希冲突？红黑树是什么？

6. 和HashTable相比？如何解决线程安全问题？

7. 进程和线程的区别？进程之间的通信？

8. JVM内存区域，堆和栈的区别，OOM发生在哪里

9. 方法A和方法B互相调用，栈溢出？

10. 讲一下GC

11. 死锁的产生条件。

12. TCP和UDP的区别？TCP三次握手四次挥手的过程。

13. Http有哪些请求。

14. 数组和链表的区别？

15. 冒泡排序，优化？提前退出、减少外层循环

16. 智力题：黑白图像哪个省电

17. 100楼扔两个鸡蛋

18. 能够实习的时间

19. 你对我们公司了解吗

20. 反问

