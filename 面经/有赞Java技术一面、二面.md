# 有赞Java技术一面

- 你先做个自我介绍吧
- 你有看过JDK的一些源码吧，说说ArrayList的底层结构是怎么样的
- 如果我add一个元素进去，会发生什么事（数组迁移、扩容）
- 扩容是在原有的数组上增加容量，还是创建一个新的数组
- 这个方法时System的native方法，你看过它的实现吗
- 让你把一个数组移动到另一个新的数组上，你会怎么去实现
- ArrayList是线程安全的吗？为什么是线程不安全的
- 你刚刚说的这个modCount是用来干嘛的
- 如果想要一个线程安全的List，有哪些
- 你对Synchronized关键字有什么理解吗
- 当一个线程拿到一个锁的时候，他会把锁的持有线程设置为自己的线程ID，为什么（可重入）
- 你看过ReentrantLock吗（讲了一堆AQS）
- AQS中有一个state值，这个值为了保证可见性做了什么处理吗（volatile）
- 你能说一下volatile的意义吗
- 你有看过线程池相关的吗，结合线程池的参数，讲一下当我添加一个任务到线程池里的时候，会发生那些事
- 控制核心线程过期的那个参数默认值是什么（false）
- 了解过类加载吗，讲一下一个class文件加载到内存中，中间经历了哪些阶段
- 如果我在自己的程序里写了一个叫ArrayList的类，它可以在程序里直接使用吗
- 如果我需要用到自己写的这个类，需要怎么去加载呢
- 我需要自己去写一个类加载器去加载他吗？
- 说一下MySQL事务的ACID
- 说一下有哪些隔离级别，分别是怎么**实现**的
- 默认的是哪个隔离级别，说一下可重复读和读已提交的区别，在**实现**上有什么区别
- MVCC你了解的也可以说一下
- 说一下不可重复读和幻读之间的区别
- 你刚刚说到了区间锁，说一下MySQL中包含区间锁功能的锁，有哪几种
  - Gap锁、Next-Key Lock、插入意向锁
- 如果要删除一条记录的话，这条记录是会直接删除掉的吗？MySQL是怎么做的，这个标识为删除的字段名是什么
  - 
- 这条记录会在什么时候会被真正移除掉？
- 说一下主键索引和二级索引之间的区别
- 一个表Tab有主键{id}和普通索引字段{user_id}，如果以user_id为查询条件，有哪些情况不会命中user_id的索引
- 这个场景，如果表里的数据只有二十条，我查其中一条数据，他会走索引吗
- InnoDB引擎有Hash索引吗
- 说说你对Spring AOP的理解，你有用过AOP做过一些事吗
- 说一下你做的这个RPC框架的结构是怎么样的
- 你这个Handler链里面有用到什么设计模式吗（责任链模式）
- 说一下你对责任链模式的理解，你觉得这个设计模式的好处是什么
- 了解过JVM吗，说一下CMS收集器的流程
- 浮动垃圾是怎么解决的
- 内存碎片如果比较严重的话会发生什么事
- 引起Full GC的原因有哪些（先讲了新老分代，问到了动态年龄判定）
- 问一个网络相关的，在浏览器中输入一个www.baidu.com，会发生哪些事（DNS、TCP、HTTP）
- 你有什么要问我的吗





# 有赞Java技术二面

- 做这个项目时，为什么选用Zookeeper；还有其他的注册中心有了解过吗，技术选型？
  - 
- **CAP**理论了解吗？Zookeeper是满足哪一种？**ZooKeeper保证的是CP**
  - 一致性（C:Consistency）：**当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态**。
  - 可用性（A:Available）：**系统必须能够在指定的时间（即响应时间）内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的**。
  - 分区容错性（P:Partition Tolerance）：**分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障**。
  - 这三个基本需求，最多只能同时满足其中的两项，**因为P是必须的,因此往往选择就在CP或者AP中**。
  - **ZooKeeper保证的是CP**
    - zookeeper在选举leader时，会停止服务，直到选举成功之后才会再次对外提供服务，这个时候就说明了服务不可用
- RPC框架的接口请求的协议是什么？（序列化、Encode、Decode）
- 序列化的意义是什么（为什么）？
- Java中如何进行序列化？如果没有序列化ID的话会产生什么问题？
  - **具体的序列化过程：**序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。
    - 一是默认的1L，比如：`private static final long serialVersionUID = 1L; `    
    - 二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如：`private static final long serialVersionUID = xxxxL;`
- 有些字段如果不想它被序列化，应该怎么做？（transient）
- Java中序列化的实现原理是什么？
- 如何保证一个单例对象在序列化、反序列化之后仍然是**单例**的？
  - `readResolve`用于*替换*从流中读取的对象。读取对象时，将其替换为单例实例。确保没有人可以通过对单例进行序列化和反序列化来创建另一个实例。
- 客户端在进行远程调用的时候，如何屏蔽掉一些建立连接等繁琐的操作？（建立**代理对象**来进行一系列操作）
- 你使用的是Cglib还是jdk的**动态代理**？这两者有什么区别？
- 你请求的路由策略是什么？（如何选择服务器、**负载均衡**）
- 你还了解哪些负载均衡算法？（一致性Hash。。。）
  - 一致性Hash解决的问题：
- 如果你的Zookeeper宕机了，那么你的RPC服务还能继续使用吗？
- 你使用CompletableFuture（CF）的意图是什么？为什么不直接使用Callable呢？CF的线程池是如何设置的？
- 现在有ABC三个线程，B对A是有结果依赖的，C没有；如何使用CF进行一个调用的链路的优化？要创建几个CF？
- CompletableFuture的核心功能其实是一个**异步编排**的问题，回去了解一下
- 你的权限管理系统为什么不使用Spring Security而是使用Shiro（技术选型）
- 如何保证一个用户在关闭浏览器之后，Session仍然可用？Server端和浏览器（前端？）层面，要做什么处理？
- 你的Session ID是如何生成的？生成策略是什么，是基于什么生成的？
- 将Session存放到Java的缓存中（HashMap），和设置在Redis中，有什么区别？除了堆内存层面，在**业务**上有什么区别？
  - **本地缓存对分布式架构支持不友好**，比如同一个相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的，因为本地缓存只在当前机器上有。
  - **本地缓存容量受服务部署所在的机器限制明显。** 如果当前系统服务所耗费的内存多，那么本地缓存可用的容量就很少。
- 如果使用本地缓存的话，如何设置过期时间，如何回收不使用的数据？
- 如果希望在每次GC的时候，都把Map中的数据回收掉，怎么做？**软引用**和弱引用有什么区别？
- Redis中有哪些数据结构，介绍一下。**ZSet**的底层数据结构是怎么样的？**跳表**的时间和空间复杂度是怎么样的？
- Redis中Key过期了，会马上被清除掉吗？
- Redis的高可用方案有哪些？如何保证**哨兵的高可用**？哨兵的**故障转移**过程是怎么样的？**选举**使用的是什么算法？
  - 
- 如何避免**缓存穿透**？布隆过滤器中查到了hash，就证明数据一定存在吗？
- 如何解决**读写热点**的问题？除了缓存击穿，如何降低Redis集群的压力？**除了使用消息队列进行削峰以外呢**？
  - 
- Java中的**泛型**是如何工作的？为什么进行类型擦除？
- 泛型的通配符是怎么样的？`T extends ...`和`？ extends ...`有什么区别？
- 是否了解PECS规则？？？
- volatile和synchronized有什么区别？synchronized是如何实现可重入功能的？
- 垃圾收集算法有哪些？new一个对象时，是如何进行**内存分配**的（在eden区进行内存分配时，如何解决多线程冲突问题？）**预分配策略**。
  - **CAS + 失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
  - **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配
- 反问

