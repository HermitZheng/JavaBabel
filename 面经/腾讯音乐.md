## 网络

- 从在浏览器输入URL到网页显示的过程，发生了什么



- 为什么HTTPS是安全的



- HTTPS工作原理

  

- CA证书的认证机制

  **采用HTTPS协议的服务器必须要有一套数字证书**，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。

  ![img](https://images2015.cnblogs.com/blog/801753/201512/801753-20151227231348796-534259362.png)

  **RSA**公钥加密算法来区分证书签名和交换密钥，通过**AES**算法来加密数据，至于**GCM**，应该是用来校验信息的。

  客户端解析证书这部分工作是由客户端的TLS来完成的，首先会验证**公钥是否有效**，如颁发机构、过期时间等等，如果发现异常则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就**生成一个随机值**，然后用证书对该随机值进行加密。

  注意一下上面提到的"发现异常"。证书中会包含**数字签名**，该数字签名是加密过的，是用**颁发机构的私钥**对本证书的公钥、名称及其他信息做hash散列加密而生成的。客户端浏览器会首先找到该证书的**根证书颁发机构**，如果有，则用该根证书的**公钥解密**服务器下发的证书，如果不能正常解密，则就是"发现异常"，说明该证书是伪造的。

  

- TCP是怎么保证可靠传输的



- socket

  它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。

  为了表示和区分已经打开的文件，UNIX/Linux 会给每个文件分配一个 ID，这个 ID 就是一个整数，被称为**文件描述符**（File Descriptor）。例如：

  - 通常用 0 来表示标准输入文件（stdin），它对应的硬件设备就是键盘；
  - 通常用 1 来表示标准输出文件（stdout），它对应的硬件设备就是显示器。

  我们可以通过 socket() 函数来创建一个网络连接，或者说**打开一个网络文件**，**socket() 的返回值就是文件描述符**。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如：

  - 用 read() 读取从远程计算机传来的数据；
  - 用 write() 向远程计算机写入数据。

  **服务端**

  - 使用 socket() 创建一个socket，使用 bind() 将socket与自己的 host 和 port 进行绑定
  - 使用 listen() 对绑定的端口进行监听，等待客户端发来的消息
  - 使用 accept() 接收客户端发来的请求，建立连接
  - 使用 write() 向客户端发送数据，最后使用 close() 关闭连接
  - 最后需要说明的是：listen() 只是让套接字进入**监听**状态，**并没有真正接收客户端请求**，listen() 后面的代码会**继续执行**，直到遇到 accept()。**accept() 会阻塞程序执行**（后面代码不能被执行），直到有新的请求到来。

  **客户端**

  - 使用 socket() 创建一个socket，使用 connect() 与指定host 和 post 的服务端进行连接
  - 连接建立之后，使用 read() 读取服务端发来的数据，最后使用 close() 关闭连接



- HTTP版本差异

  HTTP1.0：主要是**短连接**

  HTTP1.1：支持**长连接**，**流水线请求**（Pipelining），引入更多**缓存控制策略**

  HTTP2.0：

  - 多路复用：将所有传输的信息分割为更小的消息和帧，并对它们采用**二进制格式**的编码，可以**乱序**发送并组装。一个request对应一个id，这样**一个连接上可以有多个request**，每个连接的request可以随机的混杂在一起，接收方可以根据**request的 id**将request再归属到各自不同的服务端请求里面。
  - 头部压缩：对多次请求中几乎相同的请求头进行压缩
    - 随时复位：可以随时停止一个信息传输，而不用中断连接，提高带宽效率
    - **服务端推送**：例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。



1. tcp三次握手和四次挥手的过程**(为什么不可以两次握手，为什么握手要三次，挥手需要四次)**  

   **两次握手：**防止已失效的连接请求报文又重新传到了B而发生错误

   - A第一次的连接请求失效了，因而重传第二次连接请求，并成功建立连接
   - 第二次的连接结束并断开，之后第一次的连接请求又发送到了B，误以为开启下一次连接
   - 如果有第三次握手，则A不会响应B误认的连接请求

   **四次挥手：**

   - 第二次挥手和第三次挥手之间，服务器仍然在传输数据，如果合并则这部分数据丢失
   - 客户端等待时间Time_Wait为了确认第四次挥手ACK报文能传达到服务器
   - 保证本连接的所有报文段都从网络中消失（Time_Wait时间为两倍的最长报文寿命）

   

   

2. tpc如何实现可靠传输**(如何实现udp的可靠传输)**  

   TCP：校验和、流量控制、拥塞控制、ARQ协议、超时重传，有序传输（包编号seq），接收方丢弃重复数据，应用数据被分割成TCP认为最适合的数据块

   UDP：

   1. 添加seq/ack机制，确保数据发送到对端
   2. 添加发送和接收缓冲区，主要是用户超时重传。
   3. 添加超时重传机制。

   详细说明：发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。**数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。**时间到后，定时任务检查是否需要重传数据（查看缓冲区）。

   

3. tcp和udp的区别

   udp协议**不提供可靠的交付**，且进行数据交付前**不需要建立连接**。接收方在收到信息之后**不需要回复响应**。udp的首部有**8个字节**。因此udp的效率高，占用的资源较少，一般用于实时性要求较高的场景，比如**DNS域名解析、实时通讯**等。可以广播和多播。

   tcp协议提供了**可靠的交付**，且需要通过**三次握手建立连接**，连接关闭时通过**四次挥手关闭连**接。接收方在收到信息后需要**回复一条响应报文**。TCP不提供广播和多播，而是只能**端到端**传输。TCP将应用层的信息拆分成若干个段，并**通过序号标记进行有序的传输**。首部有**20-60个字节**。因而效率相对较低，占用资源较多，一般用于对数据的可靠性要求较高的场景，如文件**传输FTP、邮件SMTP、远程连接Telnet**

   

   

4. 基于UDP如何实现可靠的HTTP传输（在应用层考虑）

   - 添加seq/ack机制，确保数据发送到对端
   - 添加发送和接收缓冲区，主要是用户超时重传。
   - 添加超时重传机制。

   

- http头



- Nagle算法

  Nagle算法要求，一个TCP连接在任意时刻，最多只能有一个没有被确认的小段。所谓“小段”指的是**小于MSS的数据块**，“没有被确认”指的是**一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。**

  Nagle算法的实现规则：

  1. 如果包长度达到MSS，则允许发送；
  2. 如果该包含有FIN，则允许发送；
  3. 设置了TCP_NODELAY选项，则允许发送；
  4. 未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；
  5. 上述条件都未满足，但发生了超时（一般为200ms），则立即发送。



## 操作系统

- 什么是死锁，死锁发生的条件以及怎么避免（实现死锁）



- 进程间的通信方式有哪些



- 生产者消费者模型



- 进程调度[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)，死锁解决



- select,poll,epoll？select是阻塞的吗？





## 算法、数据结构

- 二叉树的遍历方式有哪些



- 字典查找的时间复杂度是多少，为什么



- 红黑树



- [哈希表](https://www.nowcoder.com/jump/super-jump/word?word=哈希表)冲突方法的解决办法有哪些



- Topk堆排序



- 随机播放音乐（洗牌）



## Redis

- Redis为什么快

1. 使用C语言 贴近操作系统
2. Redis将所有数据放在内存中，非数据同步正常工作中，是不需要从磁盘读取数据的
3. Redis使用单线程简化算法的实现，并发的数据结构实现不但困难且测试也麻烦，单线程避免了线程切换以及加锁释放锁带来的消耗
4. 使用多路复用，自身的事件处理模型将epoll的read、write、close等都转换成事件，不在网络I/O上浪费过多的时间







## Java







## 分布式

- 分布式锁

  

- 分布式seesion



- BASE

  BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。

  其核心思想是：虽然无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。

