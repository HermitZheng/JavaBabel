# 操作系统__笔面试知识点



1. **线程和进程的区别(可能会问到协程)**  

   - 进程是程序的一次执行过程，是程序运行的基本单位，是**资源调度的基本单位**，因此进程是动态的。系统运行一个程序，既是一个进程从创建到消亡的过程。Java的一次main函数运行，就是启动了一个JVM进程，其中的这个main函数所在的线程就是这个进程中的主线程。

   - 线程是比进程更小的一个执行单位，是**独立调度的基本单位**。进程中可以有多个线程，他们共享进程资源（同一个进程的多个线程**共享进程的堆和方法区资源**），但是每个线程有**独立的程序计数器、虚拟机栈和本地方法栈。**
   - 协程不是被操作系统内核所管理，而完全是**由程序所控制**（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程那样需要上下文切换来消耗资源，因此**协程的开销远远小于线程的开销**。

   



2. **进程的调度算法**  

   ## 1. 批处理系统

   - **先来先服务算法（FCFS）：**

     **非抢占式**的调度算法，按照请求的顺序进行调度。

     **有利于长作业，但不利于短作业**，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

   - **短作业优先（SJF）：**

     **非抢占式**的调度算法，按估计运行时间最短的顺序进行调度。

     **长作业有可能会饿死**，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

   - **最短剩余时间（SRTN）：**

     最短作业优先的**抢占式**版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

   - **高响应比优先（HRRF）：**

     是**非抢占式**的，主要用于作业调度。基本思想：每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选最高的作业投入系统运行。
      响应比 = （等待时间 + 服务时间） / 服务时间 = 等待时间 / 服务时间 + 1

   ## 2. 交互式系统

   - **时间片轮转**：（时间片到期：运行->就绪）

     将所有就绪进程按 **FCFS** 的原则排成一个队列，按CPU时间片轮流执行。如果时间片太小，会导致进程切换得**太频繁**，在**进程切换**上就会花过多时间；而如果时间片过长，那么**实时性**就不能得到保证。

   - **优先级调度**：

     为每个进程分配一个优先级，按优先级进行调度。

     为了防止低优先级的进程永远等不到调度，可以**随着时间的推移增加等待进程的优先级**。



3. linux中几种io模型(select,poll,epoll)  





4. 分页，分段，段页的区别  

   - **分页：**为了更好的管理内存，操作系统将**内存抽象成地址空间**。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页（**固定大小**的页）。这些页被映射到物理内存，但**不需要映射到连续的物理内存**，也**不需要所有页都必须在物理内存中**。当程序引用到不在物理内存中的页时，由**硬件**执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。
   - **分段**：分段的做法是把**程序**的不同部分分成段，一个段构成一个独立的地址空间。每个段的**长度可以不同**，并且可以**动态增长**。
   - **段页式：**程序的地址空间划分成多个拥有独立地址空间的段，**每个段上的地址空间划分成大小相同的页**。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

   区别：

   - 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
   - 地址空间的维度：分页是**一维**地址空间，分段是**二维**的（段号，段内地址）。
   - 大小是否可以改变：页的大小不可变，段的大小可以动态改变。
   - 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。
   - **管理方式**：操作系统必须为每个进程维护一个页表，以说明每个页对应的的**页框**。操作系统必须为每个进程维护一个段表，以说明每个段的**加载地址和长度**。





5. 操作系统的作用和功能  





6. 死锁的定义以及如何避免死锁(银行家算法)  

   当多个进程同时进入**阻塞**状态，在占有资源的同时又请求其他的资源（等待其他资源被释放），但是其他资源都被其他进程所占有，因而形成了环状的等待，所有进程无限期的阻塞。

   





7. 进程的**通信**方式  ：进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。
   - **管道**：只支持**半双工**通信（单向交替），只能在**父子**或者**兄弟**进程间通信
   - **FIFO**：也称为命名管道，去除了管道只能在父子进程中使用的限制。
   - **消息队列**：
     - 消息队列可以**独立于读写进程**存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
     - 避免了 FIFO 的同步阻塞问题，**不需要进程自己提供同步方法**；
     - 读进程可以根据消息类型**有选择地接收消息**，而不像 FIFO 那样只能默认地接收。
   - **信号量**：它是一个计数器，用于为多个进程提供对共享数据对象的访问。
   - **共享存储**：
     - 允许多个进程**共享一个给定的存储区**。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。
     - 需要使用**信号量**用来同步对共享存储的访问。
     - 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。
   - **套接字**：与其它通信机制不同的是，它可用于不同机器间的进程通信。





8. 线程的七态模型  





9. 进程间同步与互斥的区别，线程**同步**的方式   

   - 同步：多个进程因为**合作**产生的**直接制约**关系，使得进程有一定的**先后执行关系**。
   - 互斥：多个进程在同一时刻只有**一个进程**能进入临界区（访问一个资源）。

   线程的同步：多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免资源在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。

   ### 同步的方式：

   1. synchronized修饰**方法**：每个java对象都有一个内置锁，当调用该方法时必须取得内置锁，否则阻塞。

   2. 同步**代码块**：被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。

   3. 使用特殊域变量(**volatile**)：使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，每次使用它都要到主存中进行读取，而不是使用寄存器中的值 。**volatile** 关键字的主要作用就是保证变量的**可见性**然后还有一个作用是**防止指令重排序**（并不提供原子性）。

   4. 使用**重入锁**实现线程同步：

      在Java5.0中新增了一个java.util.concurrent包来支持同步。
       **ReentrantLock**类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和代码块具有相同的基本行为和语义，并且扩展了其能力。

      ```java
      class Bank {
      
          private int account = 100;
          //需要声明这个锁
          private Lock lock = new ReentrantLock();
          public int getAccount() {
              return account;
          }
          //这里不再需要synchronized 
          public void save(int money) { 
              lock.lock();      		// lock()获得锁
              try{
                  account += money;
              }finally{
                  lock.unlock();		// unlock()释放锁
              }
          }
      }
      ```

      如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码？；如果需要更高级的功能，就用ReentrantLock类，此时要注意**及时释放锁**，否则会出现**死锁**，通常在**finally**代码释放锁。

   5. 使用**局部变量**实现线程同步：

      如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该**变量的副本**，**副本之间相互独立**，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。

      ```java
      public class Bank{
          //使用ThreadLocal类管理共享变量account
          private static ThreadLocal<Integer> account = 
              new ThreadLocal<Integer>(){
                  @Override
                  protected Integer initialValue(){
                      return 100;
              }
          };
          public void save(int money){
              account.set(account.get()+money);
          }
          public int getAccount(){
              return account.get();
          }
      }
      ```



10. 动态链接库与静态链接库的区别