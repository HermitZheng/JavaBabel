# JVM__笔面试知识点：GC、垃圾收集器

程序计数器、虚拟机栈、本地方法栈三个区域为**线程私有**的，每个栈帧中分配的内存基本在类结构确定时就是已知的，当方法结束或者线程结束时，内存自然就被回收了。垃圾收集主要针对**Java堆**和**方法区**进行。

## 确定需要回收的对象

### 1. 引用计数算法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加一；当引用失效时，计数器的值就减一；任何时候计数器为零的对象就是不可能再被使用的。

但是单纯的引用计数算法很难解决两个对象之间相互循环引用的问题：当**两个对象相互引用**，除此之外没有任何其他引用时，实际上这两个对象以及不可能再被访问，但是引用计数都不为零，也就无法回收。 （循环引用）

```java
public class ReferenceCountingGC {
	public Object instance = null;
    
	public static void testGC() {
    	ReferenceCountingGC objA = new ReferenceCountingGC();
    	ReferenceCountingGC objB = new ReferenceCountingGC();
    	objA.instance = objB;
    	objB.instance = objA;
    	objA = null;
    	objB = null;
    	// 假设在这行发生GC，objA和objB是否能被回收？
    	System.gc();
	}
}
```

结果是两个对象都被回收了：**Java虚拟机并没有使用引用计数算法。**



### 2. 可达性分析算法

通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点出发根据引用关系向下搜索，搜索过程所走过的路程称为“引用链”；如果**一个对象到根节点之间没有任何引用链相连**，或者说**不可达**时，此对象就是不可能再被使用的。

![image-20200303174017723](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200303174017723.png)

固定**可作为GC Roots的对象**包括以下几种：

- 在**虚拟机栈**（栈帧中的**本地变量表**）中引用的对象：

  ​	譬如各个线程被调用的方法堆栈中的参数、局部变量等

  ```java
  public class Test {
      public static  void main(String[] args) {
          // a 是栈帧中的本地变量,充当了GC Root的作用
          Test a = new Test();
          // 当 a = null 时，a 与原来指向的实例 new Test() 断开了连接，所以对象会被回收。
          a = null;
      }
  }
  ```

- 在**方法区**中**类静态属性**引用的对象

  ​	譬如Java类的引用类型静态变量

  ```java
  public class Test {
      public static Test s;
      public static void main(String[] args) {
          Test a = new Test();
          a.s = new Test();
          // 由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接，所以 a 原来指向的对象会被回收
          a = null;
          // s 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活
      }
  }
  ```

- 在**方法区**中**常量**引用的对象

  ​	譬如字符串常量池里的引用

  ```java
  public class Test {
  	public static final Test s = new Test();
      public static void main(String[] args) {
          Test a = new Test();
          // 常量 s 指向的对象并不会因为 a 指向的对象被回收而回收
          a = null;
      }
  }
  ```

- 在**本地方法栈**中JNI引用的对象

- Java虚拟机内部的引用

  ​	如基本类型对应的Class对象、一些常驻的异常对象、系统类加载器

  

### 3. 回收方法区

方法区存放的永久代对象回收条件苛刻，回收的性价比也较低。方法区的垃圾收集主要针对两部分内容：**废弃的常量**和**不再使用的类型**

判断一个类型是否不再被使用：

- 该**类的所有实例**都已经被回收，堆中不存在任何**该类及其子类**的实例
- 加载该类的**类加载器**已经被回收
- 该类对应的**Class对象**没有在任何地方被引用，无法在任何地方通过**反射**访问该类的方法

满足以上条件的无用类“允许”被回收，可以通过-Xnoclassgc参数控制是否回收。在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常需要Java虚拟机具备类型卸载的功能，以保证不会对方法区造成过大的内存压力。



### 4. finalize()

当一个对象将被回收时，假如对象的finalize()方法**没有被覆盖**，或者**已经被虚拟机调用过**，则将其回收。

反之，虚拟机将会执行finalize()方法，如果对象通过finalize()方法重新与引用链上的任何一个对象建立关系，那么对象就完成了“自救“，不会被回收。

这个方法类似于C++的析构函数，用于“关闭外部资源”，但是因为它运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因而**不推荐使用**。使用try-finally或者其它方式可以做的更好、更及时。



### 引用类型

无论是引用计数算法判断引用数量，还是可达性分析算法判断对象的引用链是否可达，判断对象是否存活都和“引用”离不开关系。

Java提供了四种不同强度的引用类型：

#### 1. 强引用（Strongly Reference）

最传统的引用的定义，指在程序代码中普遍存在的引用赋值

```java
Object obj = new Object();
```

只要强引用关系还存在，垃圾收集器就**永远不会**回收掉被引用的对象。



#### 2. 软引用（Soft Reference）

用于描述一些还有用，但非必须的对象。

```java
Object obj = new Object();
SoftReference<Object> soft = new SoftReference<>(obj);
obj = null; // obj只被软引用关联
```

被软引用关联着的对象，在系统**将要发生内存溢出异常前**，会把这些对象列进回收范围内进行二次回收，如果这次回收还没有足够内存，才会抛出内存溢出异常。



#### 3. 弱引用（Weak Reference）

也是描述一些非必须对象，但是强度比软引用低一些。

```java
Object obj = new Object();
WeakReference<Object> weak = new WeakReference<>(obj);
obj = null;
```

**当垃圾收集器开始工作时，无论内存是否足够，都会回收掉被弱引用关联的对象。**



#### 4. 虚引用（Phantom Reference）

也被称为幽灵引用或者幻影引用，是最弱的引用关系。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```

一个对象是否有虚引用的存在，对于其生存时间完全没有影响，也无法通过虚引用得到对象的实例；虚引用唯一的作用是当引用的对象被收集器回收时，能够收到一个系统通知。



## 垃圾收集算法

### 分代收集理论

分代假说：

1. 弱分代假说：绝大多数对象都是自生自灭的
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡
3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数

记忆集：

依据跨代引用假说，我们就不应再为少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每个对象是否存在跨代引用；只需在新生代上建立一个全局的数据结构，被称为**”记忆集“**（Remember Set），这个结构把老年代划分为若干个小块，并标识出老年代中的哪些区域会被跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存才会被加入到GC Roots中进行扫描。



### 1. 标记-清除算法（老年代）

首先标记出需要回收的对象，在标记完成后，统一回收掉所有被标记的对象；或者标记存活对象，并回收未标记对象。

它有两个主要缺点：

1. 执行效率不稳定：如果Java堆中包含大量对象，且大多数都是要被回收的，就必须进行大量的标记和清除操作，执行效率随着对象数量增长而降低。
2. 内存空间碎片化问题：**产生大量不连续的内存碎片**，影响后续的内存分配。



### 2. 标记-复制算法（新生代）

半区复制：将可用内存按照容量分成大小相等的两块，当一块内存使用完时，就**将还存活着的内存全部移到另一块，并把使用过的内存一次清理掉。**

当多数对象存活时，会产生很大的复制开销；当多数对象被回收时，复制的开销较小，而且在之后分配内存时也不会有空间碎片的问题，只要移动栈顶指针，按顺序分配即可。

不足之处是**可使用内存缩小为了原来的一半**；因为一般新生代对象90%以上熬不过第一轮收集，因此不需要对半分，从而有一种优化策略称为“Appel”式回收。

把新生代区域划分为一块较大的Eden区（80%）和两块Survivor区（2*10%），每次只使用Eden和一块Survivor。当发生垃圾收集时，将存活的对象全部移动到另一块Survivor中，接着直接清空Eden和已用过的Survivor。

“Appel”式回收还有一个安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就依赖其他区域（大多是老年代）进行分配担保。



### 3. 标记-整理算法（老年代）

标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率会降低，所以老年代不能使用这种算法。

将对象标记后，**所有存活对象都向内存空间的一段移动**，然后直接清理掉边界以外的内存。

优点：**不会产生内存碎片**（影响到吞吐量）

缺点：移动存活对象并更新引用会降低效率，且进行这个操作时需要**全部暂停应用程序**（影响程序延迟）



## 内存分配和回收策略

### Minor GC 和 Full GC

- Minor GC：回收新生代，因为新生代对象存活时间很**短**，因此 Minor GC 会**频繁**执行，执行的速度一般也会比较**快**。
  - 当Eden区满时触发Minor GC，将对象移动到 from Survivor（S0）区（使用标记-复制算法），同时清空Eden
  - 下一次触发Minor GC时，会将Eden和S0的存活对象都移动到 to Survivor（S1）区，同时清空Eden和S0
  - 之后每次触发Minor GC时，会将Eden和S1的存活对象移至S0，每次回收时S0和S1职责互换
  - Eden、S0、S1的默认空间分配为8:1:1
- Full GC：回收老年代和新生代，老年代对象其存活时间**长**，因此 Full GC **很少**执行，执行速度会比 Minor GC **慢**很多。
  - Stop The World：只有垃圾回收器线程在工作，其他工作线程则被挂起。如果在此 server 收到了很多请求，则会被拒绝服务。所以要尽量减少Full GC。
  - 对新生代进行分区等操作的目的，都是**尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC**。
  - 要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，如：
    - 循环的末尾
    - 方法返回前
    - 调用方法的 call 之后
    - 抛出异常的位置

### 内存分配策略

#### 1. 对象优先在Eden分配

大部分对象在很短的时间内都会被回收，因此大多数情况下，对象在新生代Eden区中分配。当**Eden区没有足够空间时**，虚拟机将发起一次**Minor GC**。

#### 2. 大对象直接进入老年代

大对象指需要**大量连续内存**的Java对象，例如**很长的字符串或者数量庞大的数组**。大对象在Minor GC中进行复制时会产生很大的开销。且当出现许多“朝生夕灭”的大对象时，经常会提前触发垃圾收集以获取足够的连续空间。所以大对象一般会直接分配在老年代。

-XX:PretenureSizeThreshold参数，指定大于该设置值的对象直接在老年代分配内存，避免在Eden与两个Survivor区之间来回复制而产生的大量内存复制操作。

#### 3. 长期存活的对象将进入老年代

虚拟机给每个对象都定义了一个年龄计数器，对象通常在Eden诞生，当经历了一次Minor GC存活后，并且被Survivor所容纳，对象的年龄就增长1岁。增加一定的年龄之后，**年龄到达了设定的阈值**（默认为15），对象就会被移动到老年代中。

-XX:MaxTenuringThreshold参数设置对象晋升老年代的阈值。

#### 4. 动态对象年龄判定

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，**如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半**，则年龄**大于或等于**该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

#### 5. 空间分配担保

在发生Minor GC之前，虚拟机必须先检查老年代**最大可用连续空间**是否大于新生代**所有对象总空间**。如果这个条件成立，那么这一次Minor GC可以确保是安全的。如果不成立，虚拟机会查看-XX:HandlePromotionFailure参数的设置值是否允许**担保失败**。

如果允许，那会继续检查老年代的**最大可用连续空间**是否大于**历次晋升**到老年代对象的**平均大小**，如果大于，将尝试进行一次Minor GC，尽管这是有风险的；如果小于，或者参数设置为不允许冒险，则改为进行一次Full GC。

### Full GC 的触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：

#### 1. 调用 System.gc()

只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是应该让虚拟机管理内存。

#### 2. 老年代空间不足

老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。

为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

#### 3. 空间分配担保失败

使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。

#### 4. JDK 1.7 及以前的永久代空间不足

在 JDK 1.7 及以前，HotSpot 虚拟机中的**方法区**是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。

当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

#### 5. Concurrent Mode Failure

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。



## 垃圾收集器

几款经典垃圾收集器的分代以及搭配关系如图所示：

<img src="C:\Users\Hanabi\Desktop\深入理解JVM\qq_pic_merged_1583409821754.jpg" style="zoom: 33%;" />

**并行与并发**

- 并行：**多条垃圾收集器线程在同一时间协同工作**，默认此时用户线程处于等待状态
- 并发：**垃圾收集器线程与用户线程之间同一时间都在运行**，此时由于用户进程未被冻结，应用程序仍然能够相应请求；但因为垃圾收集器占用了一部分资源，应用程序的吞吐量将受到一定的影响。



### 1. Serial收集器

**新生代**收集器，基于标记-复制算法。

Serial收集器是一个**单线程**工作的收集器，它只会使用一个处理器或者一条线程去完成工作，而且在它工作时必须**暂停其他所有进程**直到收集结束。垃圾收集工作是由虚拟机自动发起和完成的，因此线程的停止对于用户是不可知、不可控的。

<img src="C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200305201212388.png" alt="image-20200305201212388" style="zoom:80%;" />

它是**客户端Client模式**下的默认收集器，与其他收集器的单线程相比，Serial**简单而高效**。由于**没有线程交互的开销**，在**单核或核心数较少**的情况下，Serial的效率较高，同时额外内存开销也较小。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。



### 2. ParNew收集器

**新生代**收集器，基于标记-复制算法。

ParNew实质上是Serial的**多线程**并行版本，是不少运行在服务端模式下的HotSpot虚拟机。除了Serial以外，目前只有它能**与CMS收集器配合工作**。

<img src="C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200305201853713.png" alt="image-20200305201853713" style="zoom:80%;" />

在单核或者低核心数时，ParNew的效率并不会比Serial好。

从JDK9开始，ParNew合并入CMS，成为它专属的新生代收集器；从此ParNew和CMS只能互相搭配使用。



### 3. Parallel Scavenge收集器

**新生代**收集器，基于标记-复制算法，被称为“吞吐量优先收集器”。

它的专注目标是**达到一个可控制的吞吐量**，即处理器用于运行用户代码的时间与处理器总消耗时间的比值。

停顿时间越短就越适合需要与用户交互或保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以高效率地利用 CPU 资源，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的分析任务。

垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价的：把新生代调小会导致垃圾收集发生的更频繁。停顿时间下降了，但是吞吐量也下降了。

<img src="C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200305204717067.png" alt="image-20200305204717067" style="zoom:80%;" />

 -XX:+UseAdaptiveSizePolicy（自适应调节策略）是一个开关参数，开启之后就不需要指定新生代大小等各种参数，虚拟机会根据系统的运行情况收集性能监控信息以动态调整这些参数，以提供最合适的停顿时间和吞吐量。



### 4. Serial Old收集器

Serial Old是Serial的**老年代**版本，同样是单线程收集器，基于标记-整理算法。

这个收集器的主要意义是供客户端模式下的HotSpot使用。JDK5之前可以与Parallel Scavenge搭配。

它也可以作为CMS收集器发生失败后的后备预案，在并发发生Concurrent Mode Failure时使用。



### 5. Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的**老年代**版本，支持多线程并发收集，基于标记-整理算法。

在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old组合。



### 6. CMS收集器

CMS收集器是一种以获取**最短回收停顿时间**为目标的收集器，在**老年代**工作，基于**标记-清除**算法；**它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

垃圾收集流程分为以下四个步骤：

- 初始标记：仅仅标记GC Roots能**直接关联**到的对象，速度很快，需暂停用户线程
- 并发标记：遍历整个对象图进行可达性分析，耗时较长但是不需要暂停用户线程
- 重新标记：修正并发标记期间因用户线程运作而发生**变动**的一部分对象的标记记录，比初始标记稍慢，需停顿
- 并发清除：**清除**标记阶段已经判断死亡的对象，因为不需要移动对象，因而可与用户线程并发

耗时最长的并发标记和并发清除阶段都可以与用户线程一起工作，因而从总体上CMS的内存回收过程是与用户线程一起并发执行的。

<img src="C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200305212439100.png" alt="image-20200305212439100" style="zoom:80%;" />

CMS被称为“并发低停顿收集器”，至少有以下三个明显缺点：

- 对处理器资源非常敏感，虽然不会造成停顿，但是因为**占用了一部分线程**，导致应用程序变慢，降低总吞吐量
- 无法处理**浮动垃圾**，可能出现Concurrent Mode Failure进而导致Full GC的产生。由于当CMS运行时用户线程也同时运行，因而此时也会继续产生一部分垃圾对象，并且需要到下一次垃圾收集时才会被清除。也是由于垃圾收集和用户进程并发进行，所以需要**预留足够的内存空间**供用户使用，因此CMS不能等到老年代全部占满后在进行垃圾收集。当CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现Concurrent Mode Failure并发失败，此时虚拟器将启动**后备预案**：冻结用户线程，临时启用Serial Old，但这样停顿时间就长了
- 由于基于标记-清除算法，会产生**大量空间碎片**，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC的情况。-XX:CMSFullCsBeforeCompaction参数要求CMS在执行若干次不整理空间的Full GC后，下一次进入Full GC之前先进行碎片整理。（此参数从JDK9开始废弃）



### 7. Garbage First收集器

Garbage First收集器（简称G1）设计思路是**面向局部收集**以及基于**Region**的内存布局形式，同时在**新老生代**工作。

G1能够建立起一个“**停顿时间模型**”，来指定在一个长度为M毫秒的时间片段里，消耗在垃圾收集上的时间不超过N毫秒，即可预测的停顿。

G1可以不用将收集范围限制在新生代或者老年代，又或者是整个Java堆；它可以面向堆内存的任何部分来组成回收集（Collection Set，CSet）进行回收，对收集区域的衡量标准从分代变为了存放垃圾数量最多、回收收益最大的区域，这就是G1的Mixed GC模式。

基于Region的堆内存布局不再坚持固定大小和数量的分代划分，而是把**连续的Java堆**划分为**多个大小相等的独立区域**（Region），每一个Region都可以根据需要扮演新生代的Eden、Survivor或者老年代空间。

<img src="C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200305230233863.png" alt="image-20200305230233863" style="zoom:80%;" />

Region中还有一类专门存储大对象的Humongous区域，G1认为只有大小超过了一个Region容量一半的对象即可判定为大对象，大多数情况下都把Humongous Region作为老年代的一部分来看待。

G1中的新生代和老年代的概念，都变成了一系列区域的动态集合，而不是固定区域，G1将Region作为每次回收的最小单位。G1会去跟踪各个Region里面的垃圾堆积的“价值”大小，即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，并根据用户设定的停顿时间 -XX:MaxGCPauseMills 来优先处理回收价值最大的那些Region。

<img src="C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200305232848498.png" alt="image-20200305232848498" style="zoom:80%;" />

G1的垃圾收集流程大致可以分为以下四个步骤：

- 初始标记：仅仅标记GC Roots能**直接关联**到的对象，并且修改TAMS的指针，让下一阶段用户线程并发时能正确地分配新对象；**停顿线程但耗时很短**，且是**借用在Minor GC的时候同步完成**
- 并发标记：对堆中的对象进行**可达性分析**，**与用户进程并发执行**；扫描完之后重新处理SATB记录下的**发生引用变动的对象**
- 最终标记：对用户线程做一个**短暂的暂停**，用于处理并发阶段后仍遗留下来的少量的SATB记录
- 筛选回收：对各个Region的回收价值和成本进行排序，根据用户期望的停顿时间来制定计划，把选择进行回收的Region中的存活对象**移动**到空的Region中，在清理掉旧的Region中的全部空间。涉及到移动操作，必须**暂停用户线程**，由多条线程并行处理

综上所述，G1并不一味追求低延迟，而是**在延迟可控的情况下获得尽可能高的吞吐量**。从G1开始的收集器都开始追求应付内存分配速率，不追求一次性把整个Java堆清理干净，只要收集速度跟得上对象分配速度就行了。

G1从**整体**看是基于标记-整理的，但从**局部**（两个Region之间）来看又是基于标记-复制，这意味着**G1不会产生内存碎片**，利于程序的长时间运行。

G1也有一些弱项：

- 由于G1用于处理**跨代指针**的卡表较为复杂，因而G1为了垃圾收集而产生的**内存占用**较大
- G1的**写屏障**较为复杂，实现为类似消息队列的结构，把写前屏障和写后屏障中要做的事放入队列，再进行异步处理，因而G1程序运行时的**额外执行负载**比CMS高

#### 关于G1的细节部分

1. **跨Region引用对象**：每个Region都维护有自己的记忆集，它们会记录下别的Region指向自己的指针并标记这些指针分别在哪些卡页的范围之内。G1的记忆集本质是是哈希表，key是别的Region的起始地址，value是一个集合，存储的是卡表的索引号。这种**双向卡表**更复杂，至少耗费10%至20%的Java堆内存。
2. **并发阶段保证收集线程和用户线程互不干扰**：通过**原始快照（SATB）**实现当用户线程改变对象引用关系时，原本的对象图结构不变，使得标记结果正确。此外，每个Region都有两个名为**TAMS**的指针，把Region中的一部分空间划分出来用于并发过程中新对象的分配；这些新对象的地址都必须在这两个指针上，都默认是**存活**。
3. **建立可靠的停顿预测模型**：以**衰减平均值**为理论基础实现。在垃圾收集过程中，G1会记录每个Region的回收耗时，每个Region记忆集中脏卡的数量等可测量的步骤花费的成本，并分析得到统计信息。衰减平均值比普通平均值更容易受到**新数据**的影响，Region的统计状态越新越能决定其回收价值。**在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region**。

