# JVM__笔面试知识点（1）：Java内存区域、类加载



## Java内存区域

| 线程私有的 | 线程共享的 |
| ---------- | ---------- |
| 程序计数器 | Java堆     |
| 虚拟机栈   | 方法区     |
| 本地方法栈 | 直接内存   |

#### 1. 程序计数器

一块较小的内存区域，可以看做是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**

另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**

从上面的介绍中我们知道程序计数器**主要有两个作用**：

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现**代码的流程控制**，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录**当前线程执行的位置**，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，计数器的值则应为空（Undefined）。

此内存区域是唯一一个规范中**没有规定任何OutOfMemoryError情况的区域**。

#### 2. Java虚拟机栈

每个方法被执行时都会同步创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。每一个方法被调用直至执行完毕的过程，都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。

**局部变量表**

- 局部变量表存放了编译期可知的各种Java虚拟机**基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，不等同于对象本身，可以是一个指向对象起始地址的指针等）和**returnAddress类型**（指向一条字节码指令的地址）。

这些数据类型以局部变量槽（Slot）来表示，其中64位长度的double和long占用两个变量槽，其余只占用一个。

可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小:

```java
java -Xss2M HackTheJava
```

该区域可能抛出以下**异常**：

- 若 Java 虚拟机栈的**内存大小不允许动态扩展**，且**线程请求的栈深度超过最大值**，会抛出 **StackOverflowError** 异常；
- 栈进行动态扩展时如果**无法申请到足够内存**，并且**垃圾回收器也无法提供更多内存**的话，会抛出 **OutOfMemoryError** 异常。

#### 3. 本地方法栈

与虚拟栈所发挥的作用非常相似，区别是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用到的本地方法服务。

本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。

本地方法栈也会抛出 StackOverflowError和OutOfMemoryError异常。

#### 4. Java堆

被**所有线程共享**的一块区域，在**虚拟机启动时创建**，是一块运行时数据区域。

此内存区域的唯一目的是存放**对象实例**，几乎所有对象实例都在这里分配内存，是**垃圾收集器管理的内存区域（GC堆）**。

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。一般可以将堆分成两块（经典分代）：

- 新生代（Young Generation）
- 老年代（Old Generation）

Java堆可以处于物理上不连续的内存空间中（不需要连续的内存），但在逻辑上它应该被视为连续的；能够可扩展的动态增加其内存。

- 如果在Java堆中**没有内存来完成实例分配**，并且堆也**无法再扩展**时会抛出OutOfMemoryError异常。

可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。

```java
java -Xms1M -Xmx2M HackTheJava
```

#### 5. 方法区

是各个**线程共享**的内存区域，它用于存放被虚拟机加载的**类型信息（类的结构）**、**常量**、**静态变量**、**即时编译器编译后的代码缓存（方法和构造函数的代码）**等数据。在**虚拟机启动时创建**，是一块运行时数据区域。

这个区域的垃圾回收目标主要是针对**常量池的回收**和对**类型的卸载**，但是一般难以实现。

HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，**从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。**

**为什么将永久代替换成元空间？**

- 永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而**元空间使用的是直接内存**，受本机可用内存的限制；虽然元空间仍旧可能溢出，但是O**OM比原来出现的几率会更小。**
- 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样**能加载更多的类**。

**方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式**。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。和堆一样不需要连续的内存，并且可以动态扩展；如果**方法区无法满足新的内存分配需求**时，会抛出 OutOfMemoryError 异常。

#### 6. 运行时常量区（方法区）

运行时常量区是**方法区的一部分**。实际上存储的还是引用，实际的对象还是在Java堆上。

Class文件中除了有**类的版本、字段、方法、接口**等描述信息外，还有**常量池表（用于存放编译器生成的各种字面量与符号引用）**，这部分内容将在**类加载后**存放到方法区的运行时常量池中。受到方法区内存的限制，当**常量池无法再申请到内存时**会抛出 OutOfMemoryError 错误。

除了在**编译期生成的常量**外，还可以动态生成，如String类的intern()方法。

#### 7. 直接内存

直接内存并不是虚拟机运行时数据区的一部分，但是也被频繁地使用；动态扩展时也会出现OutOfMemoryError 异常。

在 JDK 1.4 中新引入了 NIO 类，一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为**避免了在堆内存和堆外内存来回拷贝数据**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。



## 对象的创建

对象创建过程：

1. **类加载检查**：当虚拟机遇到一条**new指令**时，先去检查这个指令的参数**是否能在常量池中定位到一个类的引用符号**，并且检查这个符号引用代表的类**是否已被加载、解析和初始化过**。如果没有，那必须先执行相应的**类加载过程**。
2. **分配内存**：对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。
3. **初始化零值**：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
4. **设置对象头**：初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息， 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
5. **执行init方法**：根据构造方法进行对象的初始化。

### 对象的内存分配

在类检查通过后，虚拟机将为新生对象分配内存。内存划分一般有两种：

#### 1. 指针碰撞（Bump The Pointer）

假设Java堆中内存是绝对规整的，所有被使用的内存都被放在一边，空闲的放在另一半，中间放着一个指针作为分界点的指示器。只需要移动指针就能完成内存的分配。

#### 2. 空闲列表（Free List）

当被使用的内存和空闲内存相互交错在一起，虚拟机就需要**维护一个列表来记录哪些内存块是可用的**。在分配的时候从列表上找到**足够大的内存块**划分给对象实例，并**更新列表**的信息。使用哪种分配方式由**Java堆是否规整**来决定，而堆是否规整又由**垃圾收集器是否带有空间压缩整理（标记-整理、复制）功能**决定。



#### 内存分配并发问题

虚拟机采用两种方式来保证线程安全：

- **CAS + 失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

  

#### 对象的内存布局

对象在堆内存中的存储布局可以划分为三个部分：**对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。**

- 对象头包含了存储**对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等）；以及**类型指针**，即对象指向他的类型元数据的指针（来确定这个对象是哪个类的实例）。

- 实例数据包含了我们在程序代码里所定义的**各种类型的字段内容**。

- 对齐填充则起到了**占位符**的作用（任何对象的大小都必须是8字节的整数倍），因而**不是必然存在的**。



#### 对象的访问定位

 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有**使用句柄**和**直接指针**两种：

##### 使用句柄

如果使用句柄访问方式，Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的**具体地址信息**。使用句柄方式最大的好处就是reference中存储的是稳定的句柄地址，在**对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。**

##### 使用直接指针

如果使用直接指针，Java堆对象的布局就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址。使用直接指针方式最大的好处就是***速度更快***，他**节省了一次指针定位的时间开销**。



## 类加载机制

### 类的生命周期

一个Java类从开始到结束整个生命周期会经历7个阶段：**加载**（Loading）、**验证**（Verification）、**准备**（Preparation）、**解析**（Resolution）、**初始化**（Initialization）、**使用**（Using）和**卸载**（Unloading）。其中验证、准备、解析三个部分又统称为**连接**（Linking）。

![image-20200307223706159](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200307223706159.png)

解析阶段在某些情况下可以在初始化阶段之后再开始，从而支持了Java的**动态绑定**特性。

这里的固定顺序指的是**开始时间**，而不一定是等待前一项结束后才继续下一项。



### 类初始化的时机

#### 1. 主动引用

虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列**六种**情况必须对类进行初始化（加载、验证、准备都会随之发生）：

- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。常见的场景有：
  1. 使用**new关键字**实例化对象
  2. 读取或设置一个类型的**静态字段**（被final修饰、已在编译期把结果放入常量池的静态字段**（常量）除外**）
  3. 调用一个类型的**静态方法**
- 使用java.lang.reflect包的方法对类型进行**反射调用**时，如果类型没有进行过初始化，则触发其初始化。
- 当初始化类的时候，发现其**父类**没有进行过初始化，则**先触发其父类的初始化**
- 当虚拟机启动时，用户需要指定一个要执行的类（包含**main()方法**的类），虚拟机会先初始化这个类
- 当使用JDK7新加入的**动态语言支持**时，如果一个java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化
- 当一个**接口**定义了JDK8新加入的**默认方法**（被default关键字修饰的接口方法）时，如果有这个**接口的实现类发生了初始化**，那该**接口要在其之前被初始化**

#### 2. 被动引用

**有且只有**以上六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都**不会触发初始化**，称为**被动引用**。以下是被动引用的常见例子：

```java
/**
 * 被动使用类字段演示一：
 * 通过子类引用父类的静态字段，不会导致子类初始化
 **/
public class SuperClass {

    static {
        System.out.println("SuperClass init!");
    }

    public static int value = 123;
}

public class SubClass extends SuperClass {

    static {
        System.out.println("SubClass init!");
    }
}
/**
 * 非主动使用类字段演示
 **/
public class NotInitialization_1 {

    public static void main(String[] args) {
        System.out.println(SubClass.value);    //只触发父类的初始化
    }
}
```

上述代码执行后只会输出"SuperClass init!"。对于静态字段，只有**直接定义这个字段的类**会被初始化，因此触发父类的初始化而不会触发子类的初始化。

------



```java
/**
 * 被动使用类字段演示二：
 * 通过数组定义来引用类，不会触发此类的初始化
 **/
public class NotInitialization_2 {

    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[10];   //只对数组类进行初始化
    }
}
```

通过数组定义来引用类，不会触发此类的初始化。该过程会**对数组类进行初始化**，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。

------



```java
/**
 * 被动使用类字段演示三：
 * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
 **/
public class ConstClass {

    static {
        System.out.println("ConstClass init!");
    }

    public static final String HELLOWORLD = "hello world";
}

/**
 * 非主动使用类字段演示
 **/
public class NotInitialization_3 {

    public static void main(String[] args) {
        System.out.println(ConstClass.HELLOWORLD);  //对自身常量池的引用
    }
}
```

HELLOWORLD常量在**编译阶段**通过常量传播优化，已经将常量的值直接存储在**NotInitialization类的常量池**中，以后NotInitialization类对于ConstClass.HELLOWORLD常量的引用，实际上都**被转化为对自身常量池的引用**。



### 类加载的过程

包含了加载、验证、准备、解析和初始化五个阶段。

#### 1. 加载

在加载阶段，虚拟机需要完成以下三件事（重要）：

1. 通过一个类的**全限定名**来获取到**该类的二进制字节流**
2. 将这个字节流所代表的**静态存储结构**转化为**方法区**的运行时数据结构
3. 在**堆内存**中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的**访问入口**（指向方法区）

二进制字节流不一定要从某个Class文件中获取，也可以通过：

- 从ZIP**压缩包**中读取，这最终成为日后JAR、EAR、WAR格式的基础
- 从**网络**中获取，这种场景最典型的就是Web Applet
- 运行时计算生成，这种场景用的最多的就是**动态代理**技术，在 java.lang.reflect.Proxy 中就是使用了ProxyGenerator.generateProxyClass ()来为特定接口生成代理类的二进制字节流
- 由其他文件生成，典型场景如JSP文件生成对应的Class文件；从数据库中读取，从加密文件中获取等

对于**数组类**而言，本身**不通过类加载器创建**，它是由虚拟机在内存中动态构造出来的；但是数组中的**元素类型**最终还是要通过类加载器来完成加载。数组类的创建遵循以下规则：

- 如果数组的**组件类型Component**（数组去掉一个维度的类型，并非指元素类型Element）是**引用类型**，则**递归**采用加载过程去加载这个组件类型；同时这个数组类将被标识在类加载器的类名称空间上。
- 如果数组的组件类型不是引用类型（如int[]数组的组件类型是int），虚拟机将会把这个数组类标记为**与引导类加载器关联**
- 数组类的**可访问性**与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到



#### 2. 验证

目的是确保Class文件的字节流中包含的**信息符合规范**，**不会危害虚拟机自身的安全**（安全检查）。

验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重，这个阶段是非常重要的。

验证阶段大致上会完成以下四个步骤：

1. **文件格式检验**：验证字节流是否符合Class文件格式的规范，且能被当前版本虚拟机处理
2. **元数据验证**：对字节码描述的信息进行语义分析，保证其描述的信息符合规范要求
3. **字节码验证**：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的，对类的**方法体**进行校验分析，确保其方法运行时不会做出危害虚拟机的行为（仍无法确保一定安全）；为了节省该阶段的时间消耗，JDK6之后javac编译器（方法体Code属性新增了名为StackMapTable的属性）将辅助虚拟机进行字节码验证。
4. **符号引用验证**：发生在虚拟机将符号引用转化为直接引用时，检查该类是否缺少或者被禁止访问它所依赖的外部类、方法、字段等资源。



#### 3. 准备

准备阶段是正式为类中定义的变量（被static修饰的**静态变量**）**分配内存**并设置类变量**初始值**的阶段；从概念上讲这些变量所使用的内存应当在**方法区**中分配，而JDK8之后，类变量会**随着Class对象一起存放在Java堆中**。

这时候进行的内存分配**仅包括类变量**，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

类变量的初始值通常指的是该数据类型的**零值**：

```java
public static int value = 123;
```

变量value经过初始化后的值为int类型的零值0而不是123，把value赋值为123是在类的初始化阶段才进行。

当类变量是被final修饰的**常量**那么它将初始化为表达式所定义的值：

```java
public static final int value = 123;
```

编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机将会为其赋值，此时value的初始值为123。



#### 4. 解析

虚拟机将**符号引用**替换为**直接引用**的过程，某些情况下可以在初始化之后进行，这是为了支持Java的动态绑定。

- **符号引用**：以一组符号来描述所引用的目标，符号可以是任何形式的**字面量**，只要能无歧义的**定位到目标**即可。符号引用与虚拟机的内存布局无关，**不一定是已经加载到内存中的内容。**例如：import java.util.HashMap
- **直接引用**：可以直接指向目标的**指针**、**相对偏移量**或者一个能间接定位到目标的**句柄**。直接引用与虚拟机的内存布局有关，同一个符号引用在不同虚拟机上翻译出来的直接引用一般不会相同。应用的目标**必定在虚拟机的内存中存在**。例如：指针或者对象的地址。

对方法或者字段的访问，也会在解析阶段对它们的**可访问性**进行检查。



#### 5. 初始化

直到初始化阶段，虚拟机才真正开始执行类中编写的程序代码，并将主导权移交给应用程序。在准备阶段，变量已经赋过一次零值；在初始化阶段，则会根据编码制定的主观计划去初始化类变量和其他资源。即**赋值操作**。

初始化阶段就是执行**类构造器**\<clinit>()方法的过程。

- \<clinit>()方法是由编译器自动收集类中的所有**类变量的赋值动作**和**静态语句块**（static{}块）中的语句合并而成的，编译器收集的顺序是由源文件中的**顺序**决定的。

**静态语句块只能访问到它之前定义的变量，在它之后定义的变量只能对其进行赋值，而不能访问。**

```java
public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

- 因为父类的\<clinit>()会先执行，也就意味着**父类中的静态语句块要优先于子类的变量赋值操作。**

```java
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 子类的字段B的值将会是2
}
```



### 类的卸载

卸载类即该类的Class对象被GC。

卸载类需要满足3个要求:

1. 该类的**所有的实例对象都已被GC**，也就是说**堆不存在该类的实例对象**。
2. 该类没有在其他任何地方被**引用**
3. 该类的**类加载器的实例已被GC**

所以，在JVM生命周期类，由**JVM自带的类加载器加载的类是不会被卸载的**，因此 jdk 提供的类是不会被回收的。但是由我们自定义的类加载器加载的类是可能被卸载的。



## 类与类加载器

对于任意一个类，都必须由**加载它的类加载器和这个类本身一起共同确立在虚拟机中的唯一性**；每一个类加载器都有一个独立的类名称空间。

而两个类“相等”，则包括代表类的Class对象的`equals()`方法、`isAssignableFrom()`方法、`isInstance()`方法的返回结果为true，也包括了使用`instanceof`关键字做对象所属关系判定为true等情况。

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由C++实现，负责加载 `%JAVA_HOME%/lib`目录下的jar包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。
3. **AppClassLoader(应用程序类加载器)** :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。

4. Custom ClassLoader：自定义的类加载器



### 双亲委派模型

JDK9之前的Java应用都是由以上三种类加载器配合完成加载，用户也可以加入自定义的类加载器来进行拓展。

下图中的各种类加载器之间的层级关系被称为类加载器的“双亲委派模型”：

<img src="C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200309203235134.png" alt="image-20200309203235134" style="zoom:67%;" />

双亲委派模型要求除了顶层的启动类加载器以外，**所有的类加载器都要有自己的父类加载器**。不过这里加载器之间的父子关系一般不是以继承关系来实现的，而是通常使用**组合**（Composition）关系来复用父加载器的代码。

双亲委派模型的工作过程是：

- 如果一个类加载器收到了类加载的请求，他首先不会自己尝试去加载这个类，而是**把这个请求委派给父类加载器去完成**，每一个层次的类加载器都是如此。因此所有的加载请求最终都应该传送给到最顶层的**启动类加载器**中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试去自己完成加载。

使用双亲委派模型的**好处**：Java类会随着它的类加载器一起具备了一种带有优先级的层次关系，从而**使得基础类得到统一**。

例如java.lang.Object类，它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶层的启动类加载器。**因此Object类在程序的各种类加载器环境中都能保证是同一个类。**如果编写一个与rt.jar类库中已有类重名的Java类，将会发现它可以正常编译，但永远无法被加载运行。



## 一些相关问题

```java
public class Student {
    public String name;
    public Student(String name) {
        this.name = name;
    }
    public void sayName() {
        System.out.println(name);
    }
}
public class Test {
    public static void main(String[] args) {
        Student student = new Student("name");
        student.sayName();
    }
}
```

这段代码是如何加载并生效的：

1. 对 Test.java 进行编译得到 Test.class并执行。JVM会从 classpath 中找到 Test.class 的二进制文件，并将**Test的类信息加载到方法区**中。
2. JVM 找到 Test 的主程序入口，并执行main方法。
3. 执行到`Student student = new Student("name");`时发现方法区中没有Student类的信息，因此对Student类进行加载，将Student的类信息加载到**方法区**中（类加载）。
4. 在堆中**实例化**Student，并为其**分配内存**，之后调用其**构造方法**进行初始化；这个实例持有**指向方法区Student类信息的引用**。
5. 执行 `student.sayName()`时，JVM根据引用找到堆中的实例，通过实例中的引用找到其方法区中的**类型信息中的方法表**，获得`sayName()`的字节码地址
6. 执行`sayName()`方法

------

### 打破双亲委派模型

**类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？**

- 如果不是同一个类加载器加载，即使是相同的class文件，也会出现判断不相同的情况，从而引发一些意想不到的情况。**为了保证相同的class文件，在使用的时候，是相同的对象**，jvm设计的时候，采用了双亲委派的方式来加载类。
- 在JDBC4.0以后，开始支持使用spi的方式来注册这个Driver，在mysql的jar包中的 META-INF/services/java.sql.Driver 文件中指明当前使用的Driver是哪个

![image-20200809233358296](C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200809233358296.png)

```java
// 传统加载方式
// Class.forName("com.mysql.jdbc.Driver");
// SPI加载方式
String url = "jdbc:mysql://localhost:3306/test";
Connection conn = java.sql.DriverManager.getConnection(url, "root", "123456");
```

此时com.mysql.jdbc.Driver肯定不在<JAVA_HOME>/lib下，所以肯定是无法加载mysql中的这个类的。这就是双亲委派模型的**局限性**了，**父级加载器无法加载子级类加载器路径中的类**。这个mysql的drvier只有**应用类加载器**能加载，那么我们只要在启动类加载器中用方法获取应用程序类加载器，然后通过它去加载就可以了。这就是所谓的线程上下文加载器。

**线程上下文类加载器可以通过`Thread.setContextClassLoaser()`方法设置，如果不特殊设置会从父类继承，一般默认使用的是应用程序类加载器**

**不需要手动设置驱动为com.mysql.jdbc.Driver**。DriverManager有一个**静态代码块**，这会在执行`getConnection()`前运行，即`loadInitialDrivers()`,此方法会调用`ServiceLoader.load(Class<S> service, ClassLoader loader)`寻找ClassPath:META-INF/services文件夹下面java.sql.Driver的内容,即实现类。

```java
// 就是查找各个sql厂商在自己的jar包中通过spi注册的驱动
ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
// 迭代器
Iterator<Driver> driversIterator = loadedDrivers.iterator();
// 其中
public static <S> ServiceLoader<S> load(Class<S> service) {
    // 拿到线程上下文类加载器
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}
```

之后在`loadInitialDrivers()`方法中，使用ServiceLoader的迭代器进行操作，即对所有可用类进行加载：

```JAVA
try{
    while(driversIterator.hasNext()) {
        // 即 ServiceLoader.nextService()方法
        driversIterator.next();
    }
}
private S nextService() {
	...
	try {
        // cn 为class name ; loader 为之前通过线程上下文类加载器得到的
        c = Class.forName(cn, false, loader);
    } catch(...)
	...
}
```

通过线程**上下文类加载器**拿到了**应用程序类加载器**（或者**自定义**的然后塞到线程上下文中的），同时我们也查找到了厂商在子级的jar包中注册的驱动具体实现类名，这样我们就可以成功的在rt.jar包中的DriverManager中成功的加载了放在第三方应用程序包中的类了。总结即：

- 获取线程上下文类加载器，从而获取应用程序类加载器，或是自定义的类加载器
- 从META-INF/services/java.sql.Driver文件中获取具体的实现类名“com.mysql.jdbc.Driver”
- 通过线程上下文类加载器去加载这个Driver类，从而避开了双亲委派模型的弊端（**父级加载器无法加载子级类加载器路径中的类**）

------

