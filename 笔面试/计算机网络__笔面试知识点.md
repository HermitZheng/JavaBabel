

## 网络分层 ⭐⭐

OSI 将网络分为七层：应用层、表示层、会话层、运输层、网络层、数据链路层、物理层。OSI 七层协议体系结构概念清除，理论完善，但是既复杂也不实用。

TCP/IP 是一个四层体系结构，包含应用层、运输层、网际层和网络接口层（网际层是为了强调该层是为了解决不同网络的互联问题），这种体系结构得到了广泛应用。

但是 TCP/IP 从实质上讲只有最上面三层，最下面的网络接口层并没有什么具体内容，因此一般学习时结合 OSI 和 TCP/IP 的优点，采用一种五层协议的体系结构：

- **应用层**

  应用层的任务是通过应用进程之间的交互来完成特定网络应用。

  应用层协议定义应用进程之间的通信和交互规则，进程即主机中正在运行的程序。应用层协议有域名系统 DNS、支持万维网应用的 HTTP、支持电子邮件的 SMTP 等。

  应用层交互的数据单元是报文 (message)。

- **运输层**

  运输层的任务是负责向两台主机进程之间的通信提供通用的数据传输服务。

  运输层的协议主要有传输控制协议 TCP，它提供面向连接的、可靠的数据传输服务，数据传输单位是报文段(segment)；用户数据报协议 UDP，它提供无连接的、尽最大努力的数据传输服务，数据传输单位是用户数据报。

- **网络层**

  网络层的任务是负责为分组交换网上的不同主机提供通信服务，在发送数据时网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。网络层的另一个任务是选择合适的路由，使源主机运输层传下来的分组能够通过网络中的路由器找到目的主机。

  网络层的协议有 IP、ARP、ICMP、IGMP 等。

  网络层使用的中间设备是路由器。

- **数据链路层**

  数据链路层的任务是将网络层交下来的 IP 数据报组装成帧，在两个相邻结点之间的链路上传输帧，每一帧包括数据和必要的控制信息（同步信息、地址信息、差错控制等）。

  数据链路层的协议有 PPP、CSMA/CD 等。

  数据链路层使用的中间设备是网桥或桥接器。

- **物理层**

  物理层的任务是尽可能地屏蔽掉传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，使其只需考虑本层的协议和服务。

  物理层所传输的数据单位是比特，发送方发送1或0，接收方也接收1或0，物理层需要考虑用多大的电压代表1或0。

  物理层使用的中间设备是转发器。

------

## 数据链路层的协议 ⭐

### 点对点协议 PPP

在通信线路质量较差的年代，使用高级数据链路控制 HDLC 作为实现可靠传输的数据链路层协议，但现在 HDLC 已经很少使用了，对于点对点的链路，简单得多的点对点协议 PPP 是目前使用得最广泛的数据链路层协议。

PPP 协议的特点是简单、只检测差错而不纠正差错、不使用序号也不进行流量控制、可同时支持多种网络层协议。

------

### CSMA/CD 协议

以太网采用的是具有冲突检测的载波监听多点接入 CSMA/CD 协议，协议的要点是：发送前先监听、边发送边监听，一旦发现总线上出现了碰撞就立即停止发送。然后按照退避算法等待一段随机时间后再次发送，因此每一个站在自己发送数据之后的一小段时间内存在遭遇碰撞的可能性。以太网上各站点都平等地争用以太网信道。

------

## 网络层的协议 ⭐⭐

### 网际协议 IP

网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，一般指的是 IPv4。与 IP 协议配套使用的协议还有 ARP、ICMP 和 IGMP，IP 使用 ARP，ICMP 和 IGMP 要使用 IP。由于网际协议 IP 是用来使互连起来的许多计算机网络能够进行通信的，因此 TCP/IP 体系中的网络层也称网际层或 IP 层。

要解决 IP 地址耗尽的问题，根本方法是采用具有更大地址空间的新版本 IP 协议即 IPv6，向 IPv6 过渡可以使用双协议栈或使用隧道技术。

------

### 地址解析协议 ARP

由于 IP 协议使用了 ARP 协议，因此把 ARP 协议归到网络层，但 ARP 的作用是通过一个 ARP 高速缓存存储本地局域网的各主机和路由器的 IP 地址到硬件地址的映射表，以从网络层的 IP 地址解析出在数据链路层使用的硬件地址，因此也可以把 ARP 划归在数据链路层。与 ARP 对应的协议是 RARP，逆地址解析协议，作用是使只知道自己硬件地址的主机能够找出 IP 地址，但被 DHCP 协议取代。

------

### 路由选择协议 RIP/OSPF/BGP-4

路由选择协议有两大类：内部网关协议，如 RIP 和 OSPF；外部网关协议，如 BGP-4。

RIP 是分布式的基于距离向量的路由选择协议，只适用于小型互联网。RIP 按照固定的时间间隔与相邻路由器交换信息，交换的信息是当前路由表。OSPF 是分布式的链路状态协议，适用于大型互联网，只在链路状态发生变化时才向本自治系统中的所有路由器用洪泛法发送与本路由器相邻的所有路由器的链路状态信息。

BGP-4 是不同自治系统的路由器之间交换路由信息的协议，是一种路径向量路由选择协议。其目标是寻找一条能够到达目的网络且比较好的路由而不是最佳路由。

------

### 网际控制报文协议 ICMP

ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去，使用 ICMP 并非为了实现可靠传输，ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。

ICMP 的一个重要应用就是分组间探测 PING，用来测试两台主机之间的连通性，PING 使用了 ICMP 回送请求与回送回答报文。

------

### 网际组管理协议 IGMP

IP 多播使用 IGMP 协议，IGMP 并非在互联网范围内对所有多播组成员进行管理，它不知道 IP 多播组包含的成员个数也不知道这些成员都分布在哪些网络上。

IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机上的某个进程参加或推出了某个多播组。

------

## 运输层的协议 ⭐⭐⭐

### 用户数据报协议 UDP

UDP 只在 IP 的数据报服务上增加了很少一点功能，就是复用和分用以及差错检测，其特点主要是：UDP是无连接的，发送数据之前不需要建立连接；UDP 使用尽最大努力交付，不保证数据传输的可靠性；UDP 是面向报文的，发送方 UDP 对应用程序交下来的报文在添加首部后就向下交付 IP 层；UDP 没有拥塞控制；UDP 支持一对一、一对多、多对一和多对多的交互通信；UDP 的首部开销小，只有 8 个字节，TCP 需要 20 字节。

------

### 传输控制协议 TCP （重点）

#### 特点

- TCP是面向连接的运输层协议，所谓面向连接，就是指TCP在进行数据通信前需要先建立连接，主要是通过三次握手机制实现，在进行数据通信后，需要断开连接，主要是通过四次挥手机制实现。
- 每条TCP连接只能有两个端点，每一条TCP连接都是两个端点之间的通信。
- TCP提供可靠的交付服务，通过TCP发送的数据无差错，不丢失，不重复。
- TCP是全双工的通信，在发送端和接收端都设有缓存，发送方将数据发送到缓存后就可以做自己的事，接收方将数据放入缓存，上层应用程序会在合适的时机来获取数据。
- TCP是面向字节流的，所谓流就是流入进程或者从进程重流出的字节序列。虽然应用进程和TCP的交互是一次一个数据块，但是TCP会将数据块看成一连串无结构的字节流，不能保证发送的数据块和接收的数据块大小是一致的，但是字节流一定是完全一样的。

#### 如何保证可靠

TCP的发送的报文是交给IP层传送的，而IP只能提供尽最大努力服务，所以TCP必须采取适当的措施才能使得两个运输层之间的通信变得可靠。理想的通信有两个条件，第一是传输的数据不会出现差错，第二是无论发生数据的速度有多快，接收端都来得及接收。但是在现实的网络环境下几乎是不可能实现的，TCP使用了重传机制来解决传输数据出错的问题，使用流量控制来降低发送端的速度，以便接收端来的及接收。

##### **停止等待协议**

每发送一个分组就停下来，等收到了对方对该分组的确认之后再继续发送下一个分组。每发送完一个分组就设置一个超时计时器，如果在规定的时间内没有收到分组的确认消息，就会进行超时重传。在规定时间内收到了确认消息就会撤销计时器。

同时需要注意三点：①计时器设置的超时时间应该稍微长于分组的往返时间，如果时间太长通信效率就会很低，如果时间过短会产生不必要的重传，浪费网络资源。②为每一个分组都设有一个副本，以便超时重传时使用，当收到了分组的确认后再进行清除。③分组和确认分组都必须进行编号，这样才能明确是哪一个分组收到了确认。

##### **ARQ协议**

假设分组的确认丢失了，发送方在设定的超时时间内没有收到确认，不知道是自己发送的分组丢失还是接收方的确认丢失，因此发送方需要重传分组。当接收方收到了分组后就丢失这个分组，重新发送确认。

还有一种情况是分组没有丢失但是晚到了，发送端会受到重复确认，会收下并且丢弃，接收端仍然会收到重复的分组，同样丢弃并确认。

上述确认和重传机制，即ARQ automatic repeat request，自动重传请求，接收端不需要向发送端发送重传请求，当超过指定时间时发送端会自动进行超时重传。

##### **效率问题**

停止等待协议的优点是简单，缺点是信道利用率太低。信道利用率为TD/(TD+RTT+TA)，TD是发送分组的时间，T2是发送确认分组的时间，RTT是往返时间，当RTT远大于TD时通信效率就会非常低。为了提高传输效率，可以采用流水线传输，例如连续ARQ协议和窗口滑动机制。

##### **连续ARQ**

连续ARQ规定每收到一个确认就把发送窗口向前滑动一个分组的位置，接收方一般采用累积确认的方式，就是说接收方不必对收到的分组逐个确认，只需要对按序到达的最后一个分组进行确认。优点是实现容易，即使确认丢失也不必重传，确认是不能向发送方反映出接收方已经正确收到的所有分组的消息。例如发送方发生了5个分组，第3个分组丢失了，接收方只能确认前2个，发送方必须把后面3个都重新发送。

##### **滑动窗口机制**

滑动窗口以字节为单位。发送端有一个发送窗口，窗口重的序号是允许发送的序号，窗口的后沿是已经发送并且确认的序号，窗口的前沿是不允许发送的序号。窗口的后沿可能不动（代表没有收到新的确认），也有可能前移（代表收到了新的确认），但是不会后移（不可能撤销已经确认的数据）。窗口的前沿一般是向前的，也有可能不动（表示没有收到新的请求或对方的接收窗口变小），也有可能收缩，但是TCP强烈不建议这么做，因为发送端在收到通知前可能已经发送了很多数据，此时如果收缩窗口可能会产生错误。

滑动窗口的状态需要3个指针p1，p2和p3。p1之前的序号表示已经发送并且确认的，p1到p2的序号表示已经发送但还没有确认的，p2到p3表示允许发送的序号，也叫可用窗口，p1到p3表示发送窗口，p3之后的序号表示不可发送的。

发送缓存用来暂时存放发送应用程序传给发送方TCP准备发送的数据和已经发送但还没确认的数据。

接收缓存用来暂时存放按序到达的但尚未被应用程序读取的数据，未按序到达的数据。

注意三点：①发送窗口根据接收窗口设置，但并不总是一样大，还要根据网络的拥塞情况调整。②对于不按序到达的数据，TCP通常存放在接收窗口，等到字节流缺少的字节收到后再按序交付上层应用程序。③接收方必须有累积确认功能，可以减小传输开销，可以在合适的时候发送确认，也可以在自己有数据需要发送时捎带确认。但是接收方不能过分推迟发送确认，不能超过0.5秒。

------

##### 流量控制

一般我们都希望发送数据的速度尽可能快，但如果发送数据的速度过快，接收端来不及接收，就可能导致数据丢失的问题。所谓流量控制，就是根据接收端的接收能力，动态地调整发送端的发送速度，确保接收端来的及接收。流量控制主要是通过滑动窗口机制实现的。

发送窗口不能超过接收方的接收窗口，在0窗口通知后可能会出现死锁问题，接收方的接收缓冲又有了一些存储空间，但该通知丢失了，发送方和接收方互相等待消息。TCP为每一个连接设有一个持续计时器，只要收到了0窗口通知就启动计时器，到时候发送1字节大小的0窗口探测报文，如果仍是0就重置计时器，如果不是0就打破了死锁的僵局。

------

##### 拥塞控制

当网络中对资源的需求超过了资源的可用量，就叫做拥塞。当吞吐量明显小于理想的吞吐量时就出现了轻度拥塞，当吞吐量随着负载的增加反而下降时，网络就进入了拥塞状态。当吞吐量降为0时，网络已无法正常工作，进入了死锁。拥塞控制就是尽量减少注入网络的数据，减轻网络中的路由器和链路的负担。

拥塞控制是一个全局性的问题，它涉及网络中的所有路由器和主机，而流量控制只是一个端到端的问题，是两个端点之间通信量的控制。

拥塞控制有开环和闭环手段，开环就是在设计网络时事先将有关发生阻塞的因素考虑到，缺点是系统一旦开始运行就不能更改。闭环则是基于反馈环路动态处理，监测网络以便检测拥塞发生的时间和地点，把拥塞发生的信息传送到可采取行动的地方，调整网络系统的运行解决问题。

拥塞控制主要有四个方法，慢开始，拥塞避免，快重传和快恢复。

所谓慢开始，就是基于窗口的拥塞控制，发送端设有一个拥塞窗口，拥塞窗口取决于网络的拥塞程度，发送窗口就等于拥塞窗口，初始时为了防止注入过多的数据引起网络拥塞，所以将拥塞窗口值设为1，然后逐渐增大拥塞窗口，逐渐增大发送窗口，每经过一次传输轮次，拥塞窗口就加倍。有一个慢开始门限，当小于该值时就使用慢开始，等于时既可以使用慢开始也可以使用拥塞避免，大于该值时使用拥塞避免。

拥塞避免就是每经过一个往返时间RRT将拥塞窗口的值增加1，而不是像慢开始那样加倍地增大拥塞窗口。慢开始不是指窗口增大的速度慢，而是在TCP开始发生报文时先设置拥塞窗口为1，使发送方开始只发送一个报文段，相比一下将许多报文注入到网络慢。

但是有时候个报文段丢失，而网络中并没有出现拥塞，错误地导致慢开始，降低了传输效率。这时应该使用快重传来让发送方尽早知道出现了个别分组的丢失，快重传要求接收端不要等待自己发送数据时再捎带确认，而是要立即发送确认。即使收到了乱序的报文段后也要立即发出对已收到报文段的重复确认。当发送端连续收到三个重复的确认后就知道出现了报文段丢失的情况，就会立即重传，快重传可以使整个网络的吞吐量提升约20%。

当发送方知道了只是丢失了个别报文段使，不会使用慢开始，而是使用快恢复来设置阻塞窗口的值，并开始执行拥塞避免算法。

------

#### 三次握手

TCP是全双工通信，任何一方都可以发起建立连接的请求，假设A是客户端，B是服务器。

初始时A和B均处于CLOSED状态，B会创建传输进程控制块TCB，然后处于LISTEND状态，监听端口是否收到了TCP请求以便及时响应。

当A要发生数据时，就向B发送一个连接请求报文，TCP规定连接请求报文的SYN=1，ACK=0，SYN表示synchronization，ACK表示acknowledgement，SYN不可以携带数据，但要消耗一个序号，此时A发送的序号seq假设为x。发送完之后，A就进入了SYN-SENT同步已发送状态。

当B收到了A的连接请求报文后，如果B同意建立连接，会发送给A一个确认连接请求报文，其中SYN=1，ACK=1，ack=x+1，seq=y，ack的值为A发送的序号加1，ACK可以携带数据，如果不携带的话，则不消耗序号。发送完之后，B进入SYN-RCVD同步已接收状态。

当A收到了B的确认连接请求报文后，还要对该确认再进行一次确认，报文的ACK=1，ack=y+1，seq=x+1，发送之后A处于established状态，当B接收到该报文后也进入established状态。

之所以要进行三次握手，是因为第二次握手时A知道了自己的发送和接收是没有问题的，而第三次握手时B才能知道自己的发送和接收也都是没有问题的。同时三次握手防止了已失效的连接请求问题，假设这样一种正常情况，A发送的第一个连接请求报文丢失了，之后超时重传，建立了连接，通信之后释放了连接。但假设A第一个发送的连接请求报文并没有丢失，而是在网络中某结点停滞了，之后又到达了B。如果是两次握手，此时B会以为是A请求建立连接，同意之后并不会收到任何数据，因为A已经关闭了，此时B的资源就会被白白浪费。

------

#### 四次挥手

当A已经没有要发送的数据了，决定释放连接，就会发送一个终止连接报文，其中FIN=1，seq=u，u的值为之前A发送的最后一个序号+1。此时A进入FIN-WAIT-1状态。

B收到该报文后，发送给A一个确认报文，ACK=1，ack=u+1，seq=v，v的值为B之前发送的最后一个序号+1。此时A进入了FIN-WAIT-2状态，但B进入了CLOSE-WAIT状态，但连接并未完全释放，B会通知高层的应用层结束A到B这一方向的连接，此时TCP处于半关闭状态。

当B发送完数据后，准备释放连接时就向A发送连接终止报文，FIN=1，同时还要重发ACK=1，ack=u+1，seq=w（在半关闭状态B可能又发送了一些数据）。此时B进入LAST-ACK状态。

A收到连接终止报文后还要再进行一次确认，确认报文中ACK=1，ack=w+1，seq=u+1。发送完之后进入TIME-WAIT状态，等待2MSL之后进入CLOSED状态，B收到该确认后也进入CLOSED状态。

MSL是最大报文段寿命，之所以要等待2MSL是为了保证A发送的最后一个ACK报文能被B接收，如果A发送的确认报文丢失，B没有收到就会超时重传之前的FIN+ACK报文，而如果A在发送了确认报文之后就立即释放连接就无法收到B超时重传的报文，因而也不会再一次发送确认报文段，B就无法正常进入CLOSED状态。第二点原因是2MSL时间之后，本连接中的所有报文就都会从网络中消失，防止出现三次握手中的已失效的请求报文问题，影响下一次的TCP连接。

之所以不是三次挥手是因为服务器TCP是全双工的，当A发送完数据之后可能B还没有发送完，当B发送完所有的数据之后才会关闭B到A方向的连接。

除此之外，TCP还设有一个保活计时器，用于解决服务器故障的问题，服务器每收到一次客户的数据就重新设置保活计时器，时间为2小时。如果2小时内没有收到就间隔75秒发送一次探测报文，连续10次都没有响应后就关闭连接。

------

## 应用层的协议 ⭐⭐⭐

### 域名解析系统 DNS

DNS 被设计为一个联机分布式数据库系统，并采用客户服务器方式。DNS 使大多数名字都在本地进行解析，仅少量解析需要在互联网上通信，因此 DNS 的效率很高。由于 DNS 是分布式系统，即使单个计算机出现了故障也不会妨碍到整个 DNS 系统的正常运行。

**域名的解析过程**

主机向本地域名服务器的查询一般都采用递归查询，递归查询指如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份向其他根域名服务器继续发出查询请求报文。递归查询额结果是要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。

本地域名服务器向根域名服务器查询通常采用迭代查询，迭代查询指当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉它该向哪一个域名服务器进行查询。本地域名服务器也可以采用递归查询，这取决于最初的查询请求报文设置的查询方式。

------

### 文件传送协议 FTP

FTP 使用 TCP 可靠的运输服务，FTP 使用客户服务器方式，一个 FTP 服务器进程可以同时为多个客户进程提供服务，在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：控制连接和数据连接，实际用于传输文件的是数据连接。

------

### 超文本传输协议 HTTP （重点）

HTTP是超文本传输协议，规范了浏览器如何向万维网服务器请求万维网文档，服务器如何向浏览器发送万维网文档。从层次的角度看，HTTP是面向事务的应用层协议，是浏览器和服务器之间的传送数据文件的重要基础。

##### 特点

HTTP是无状态的，之所以说无状态是因为HTTP对事务没有记忆性。同一个客户第二次访问同一个服务器，服务器的响应结果和第一次是一样的。HTTP的无状态简化了服务器的设计，允许服务器支持高并发的HTTP请求。如果要解决无状态的问题，可以使用cookie和session。Cookie相当于服务器给浏览器的一个通行证，是一个唯一识别码，服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器，服务器就可以识别是否是同一个客户。Session是服务器的会话技术，是存储在服务器的。区别：①Cookie只能存储ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选Session。②Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密。③对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 

------

##### 结构

HTTP报文分为HTTP请求报文和响应报文，请求报文由请求行（请求方法，请求资源的URL和HTTP的版本）、首部行和实体（通常不用）组成。响应报文由状态行（状态码，短语和HTTP版本）、首部行和实体（有些不用）组成。

------

##### 方法

GET：主要同于获取资源，用于访问被URI统一资源标识符识别的资源。

POST：主要用于传递信息给服务器。

参数：GET和POST的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而POST的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具查看。

安全性：安全的HTTP方法不会改变服务器状态，也就是说它只是可读的。GET方法是安全的，而POST却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 

发送数据：XMLHttpRequest是一个 API，在Ajax中大量使用。它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。 

使用XMLHttpRequest时，GET请求发送一个TCP数据包，浏览器同时发送HTTP header和data，服务器响应状态码200。POST每次发送两个TCP数据包，浏览器先发送HTTP header，服务器收到后返回100（continue），浏览器再继续发送data，服务器响应200。

PUT 上传文件 DELETE 删除文件 OPTIONS 查看当前URL支持的HTTP方法 HEAD 获取首部

------

##### 流程

①先检查输入的URL是否合法，然后查询浏览器的缓存，如果有则直接显示。

②通过DNS域名解析服务解析IP地址，先从浏览器缓存查询、然后是操作系统和hosts文件的缓存，如果没有查询本地服务器的缓存。

③通过TCP的三次握手机制建立连接，建立连接后向服务器发送HTTP请求，请求数据包。

④服务器收到浏览器的请求后，进行处理并响应。

⑤浏览器收到服务器数据后，如果可以就存入缓存。

⑥浏览器发送请求内嵌在HTML中的资源，例如css、js、图片和视频等，如果是未知类型会弹出对话框。

⑦浏览器渲染页面并呈现给用户。

------

##### HTTP1.1

HTTP1.0使用的是非持续连接，每次请求文档就有2倍的RTT开销，另外客户和服务器每一次建立新的TCP连接都要分配缓存和变量，这种非持续连接会给服务器造成很大的压力。

HTTP1.1使用的是持续连接，服务器会在发送响应后在一段时间内继续保持这条连接，使同一个浏览器和服务器可以继续在这条连接上传输后续的HTTP请求和响应报文。HTTP1.1的持续连接有两种工作方式，非流水线和流水线方式。非流水线方式就是客户在收到前一个响应后才能发送下一个请求，流水线方式是客户收到响应前就能连着发送新的请求。

------

##### HTTPS

**特点**

HTTP有很大的安全隐患：使用明文进行通信，内容可能会被窃听。不验证通信方的身份，通信方的身份有可能遭遇伪装。无法证明报文的完整性，报文有可能遭篡改。 

HTTPS是以安全为目标的HTTP通道，S代表security，让HTTP先和SSL通信，再由SSL和TCP 通信，也就是说 HTTPS使用了隧道进行通信。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

HTTP的端口是80，而HTTPS的端口是443。

**流程**

加密算法主要有对称加密和非对称加密，对称加密的运算速度快，但安全性不高。非对称密钥加密，加密和解密使用不同的密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 

非对称密钥除了用来加密还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。非对称加密的运算速度慢，但是更安全。HTTPS采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。

- 浏览器和服务器建立TCP连接后，会发送一个证书请求，其中包含了自己可以实现的算法列表和一些必要信息，用于商议双方使用的加密算法。
- 服务器收到请求后会选择加密算法，然后返回证书，包含了服务器的信息，域名、申请证书的公司、加密的公钥以及加密的算法等。
- 浏览器收到之后，检查签发该证书的机构是否正确，该机构的公钥签名是否有效，如果有效就生成对称密钥，并利用公钥对其加密，然后发送给服务器。
- 服务器收到密钥后，利用自己的私钥解密。之后浏览器和服务器就可以基于对称加密对数据进行加密和通信。

------

### 电子邮件系统协议 SMTP/POP3/IMAP

一个电子邮件系统有三个主要组成构件，即用户代理、邮件服务器、以及邮件协议。

从用户代理把邮件传送到邮件服务器，以及在邮件服务器之间的传送都要使用 SMTP，但用户代理从邮件服务器读取邮件时则要使用 POP3 或 IMAP 协议。

基于万维网的电子邮件使用户可以利用浏览器收发电子邮件，用户浏览器和邮件服务器之间使用 HTTP 协议，而邮件服务器之间的传送仍然使用 SMTP 协议。

------

### 简单网络管理协议 SNMP

SNMP 由三部分组成，SNMP 本身，负责读取和改变各代理中的对象名及其状态数值；管理信息结构 SMI，定义命名对象和对象类型的通用规则，以及把对象之间值进行编码的基本编码规范 BER；管理信息库 MIB，在被管理的实体中创建命名对象并规定其类型。

------

## WEB安全 ⭐⭐

### 概述

计算机网络面临的威胁主要有被动攻击和主动攻击。

**被动攻击**指攻击者从网络上窃听他人的通信内容，也叫截获。在被动攻击中，攻击者只是观察和分析某一协议数据单元PDU而不干扰信息流。攻击者可以通过观察PDU的协议控制信息部分，了解正在通信的协议的地址和身份，通过研究PDU的长度和发送频度，了解所交换的数据的某种性质。这种攻击又叫做流量分析。

**主动攻击**包括：

- **篡改**：攻击者故意篡改网络上传输的报文，包括彻底中断传送的报文，甚至把完全伪造的报文发给接收端，这种攻击方式也叫做更改报文流。
- **恶意程序**：计算机病毒，能够传染其他程序的程序，主要通过修改其他程序来把自身或自身的变种复制进去完成。计算机蠕虫，通过网络通信能把自己从一个结点发往另一个节点并且自动启动运行的程序。特洛伊木马，它执行的功能并非声称的功能而是恶意程序，例如一个编译程序除了完成编译任务外还偷偷地复制源程序。逻辑炸弹，当运行环境满足某种特殊条件时就会执行特殊功能的程序，例如当日期为22号且为周三的时候就会删除所有文件。后门入侵，指利用系统实现中的漏洞通过网络入侵系统。流氓软件，一种未经用户同意就在用户计算机上安装并损害用户利益的软件。
- **拒绝服务DoS**：攻击者向互联网上某个服务器不停地发送大量分组，使其无法提供正常服务甚至完全瘫痪。如果从互联网成百上千的网站一起攻击一个网站就叫做分布式拒绝服务DDoS，有时也叫网络宽带攻击。
- **ARP欺骗**：在使用以太网交换机的网络中，攻击者向某个以太网交换机发送大量的伪造源MAC的地址，以太网交换机收到这样的帧就把虚假的MAC源地址填入到交换表中，由于伪造的数量很大很快就填满了表，导致以太网交换机无法正常工作。

对于主动攻击可以采取适当的措施检测，对于被动攻击通常是检测不出来的。根据这些特点，得出计算机网络安全的主要目标如下：①防止报文内容分析和流量分析。②防止恶意程序。③防止更改报文流和拒绝服务。

**安全的计算机网络有4个目标**：①保密性，只有信息的发送方和接收方看得懂信息，这是最基本的要求，需要利用密码技术实现。②端点鉴别，鉴别信息的发送方和接收方的真实身份，对于主动攻击非常重要。③信息完整性，确保信息的内容没有被篡改过，和端点鉴别密不可分。④运行安全性，通过访问控制来控制权限，规定每个用户的访问权限。

------

### 密码体制

**对称密码密钥体制**

加密密钥和解密密钥使用相同的密码体制，例如数据加密标准DES，保密性取决于对密钥的保密，而算法是公开的。在DES之后提出了高级加密标准AES来取代DES。

**公钥密码体制**

又叫公开密钥密码体制，加密和解密使用不同的密钥。产生的主要原因是对称密码密钥体制的密钥分配问题，如果事先约定密钥，就会给密钥的管理和分配带来很大的不便。另一个原因是对于数字签名的需要，许多应用中人们需要通过对纯数字的电子信息签名，表明该信息是由某个特定的人产生的。

------

### 数字签名

确保实现以下功能：①报文鉴别，接收者能够核实发送者的身份。②报文的完整性，接收者可以确信收到的报文没有被人篡改过。③不可否认，发送方事后不能抵赖对报文的签名。

------

### 鉴别

**报文鉴别：**鉴别所收到的报文的确是报文发送者自己发送的，而不是其他人伪造或篡改的，包含了端点鉴别和报文完整性的鉴别，通过密码散列函数如MD5、SHA-1，报文鉴别码等实现。

**实体鉴别：**仅鉴别发送报文的实体，可以是一个人也可以是进程和服务器，这就是端点鉴别。报文鉴别需要对每一个报文进行鉴别，实体鉴别是在系统接入的全部时间内对和自己通信的对方实体验证一次。

------

### 网络层安全协议

IPsec，不是一个单独的协议而是IP层提供网络通信安全的协议族，没有限定用户使用哪种加密和鉴别算法，是一个框架，允许通信双方选择合适的算法和参数，为保证互操作性，实现了一套加密算法。

可以划分为三部分：①IP数据报格式的2个协议，鉴别首部AH和封装安全有效载荷ESP。AH可以提供源点鉴别和数据完整性，但是不能保密，而ESP三者皆可。②有关算法的协议。③互联网密钥交换协议IKE。使用AH或ESP的数据报又叫IP安全数据报，有两种工作方式：运输方式，在整个运输层的报文段前后加上若干控制信息，再加上IP首部构成IP安全数据报。隧道形式，在原始IP数据报的前后添加若干控制信息，再加上新的IP首部构成一个IP安全数据报。

------

### 运输层安全协议

SSL安全套接字层/TLS 运输层安全

SSL是Netscape开发的安全协议，广泛用于基于万维网的各种网络应用，SSL作用于端系统的应用层HTTP和运输层之间，在TCP之上建立一个安全的连接通道，为TCP传输的数据提供安全保障。SSL的服务：①SSL服务器鉴别，允许用户鉴别服务器的身份，支持SSL客户端通过验证服务器证书，鉴别服务器身份并获取公钥。②SSL客户鉴别，SSL可选的安全服务，允许服务器证实客户身份。③加密的SSL会话，对客户和服务器发送的所有报文进行加密，并检测报文是否被篡改。

------

### 防火墙与入侵检测

恶意用户或软件通过网络利用系统的漏洞进行入侵，包括病毒、木马、DoS等。之前讨论的所有安全机制都不能有效的解决这些问题。

**防火墙**

一种访问控制技术，严格控制进出网络的分组，禁止任何不必要的通信，从而减少潜在侵入的发生。防火墙是一种特殊编程的路由器，安装在一个网点和网络中的其余部分之间，目的是实施访问控制策略。策略是由防火墙单位自行制定的，一般防火墙内的网络叫做可信任网络，防火墙之外的网络叫做不可信网络。防火墙的主要技术分为分组过滤和应用网关。

**入侵检测IDS**

防火墙应用于入侵发生前，但防火墙不可能阻止所有入侵，所以需要第二道防线也就是入侵检测，应用于入侵发生时。①基于特征的入侵检测，维持一个已知攻击特征的数据库，每个特征是一个于某种入侵活动相关联的规则集，缺点是只能检测已知攻击，对未知攻击束手无策。②基于异常的入侵检测，通过观察正常运行的网络流量，学习正常流量的统计特性和规律，当检测到网络中的流量不合规律时就认为可能发生了入侵。



## 传输层

1. tcp三次握手和四次挥手的过程**(为什么不可以两次握手，为什么握手要三次，挥手需要四次)**  

   **两次握手：**防止已失效的连接请求报文又重新传到了B而发生错误

   - A第一次的连接请求失效了，因而重传第二次连接请求，并成功建立连接
   - 第二次的连接结束并断开，之后第一次的连接请求又发送到了B，误以为开启下一次连接
   - 如果有第三次握手，则A不会响应B误认的连接请求

   **四次挥手：**

   - 第二次挥手和第三次挥手之间，服务器仍然在传输数据，如果合并则这部分数据丢失
   - 客户端等待时间Time_Wait为了确认第四次挥手ACK报文能传达到服务器
   - 保证本连接的所有报文段都从网络中消失（Time_Wait时间为两倍的最长报文寿命）

   

   

2. tpc如何实现可靠传输**(如何实现udp的可靠传输)**  

   TCP：校验和、流量控制、拥塞控制、ARQ协议、超时重传，有序传输（包编号seq），接收方丢弃重复数据，应用数据被分割成TCP认为最适合的数据块

   UDP：

   1. 添加seq/ack机制，确保数据发送到对端
   2. 添加发送和接收缓冲区，主要是用户超时重传。
   3. 添加超时重传机制。

   详细说明：发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。**数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。**时间到后，定时任务检查是否需要重传数据（查看缓冲区）。

   

3. tcp和udp的区别

   udp协议**不提供可靠的交付**，且进行数据交付前**不需要建立连接**。接收方在收到信息之后**不需要回复响应**。udp的首部有**8个字节**。因此udp的效率高，占用的资源较少，一般用于实时性要求较高的场景，比如**DNS域名解析、实时通讯**等。可以广播和多播。

   tcp协议提供了**可靠的交付**，且需要通过**三次握手建立连接**，连接关闭时通过**四次挥手关闭连**接。接收方在收到信息后需要**回复一条响应报文**。TCP不提供广播和多播，而是只能**端到端**传输。TCP将应用层的信息拆分成若干个段，并**通过序号标记进行有序的传输**。首部有**20-60个字节**。因而效率相对较低，占用资源较多，一般用于对数据的可靠性要求较高的场景，如文件**传输FTP、邮件SMTP、远程连接Telnet**

   

   

4. 基于UDP如何实现可靠的HTTP传输（在应用层考虑）

   - 添加seq/ack机制，确保数据发送到对端
   - 添加发送和接收缓冲区，主要是用户超时重传。
   - 添加超时重传机制。

   

5. 导致 TCP 连接断连的因素

   理想状态下，一个 TCP 连接可以被长期保持。然而，在实际应用中，客户端或服务器端上维持的一个看似正常的 TCP 连接可能已经断连。TCP 连接主要受到两个方面的影响而导致断连：网络中间节点和客户端 / 服务器节点参与通信的两方节点。

   在实际网络应用中，两个主机之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等。因此，两个主机之间 TCP 连接的保持同样会受到中间节点的影响，尤其是会受到**防火墙**（软件或硬件防火墙）的限制。

   - 防火墙的工作特性决定了要维护一个网络连接就需要耗费较多的资源，并且企业防火墙常常位于企业网络的出入口，长时间维护非活跃的 TCP 连接必将导致网络性能的下降。因此，大部分防火墙**默认会关闭长时间处于非活跃状态的连接**而导致 TCP 连接断连。
   - 对于一个 TCP 连接两端的主机而言，创建 TCP 连接需要耗费一定的系统资源。如果不再使用某个连接，那么我们总是希望进行通信的两个主机能够主动关闭相应的连接，以便释放所占用的系统资源。然而，如果由于**客户端出现异常 ( 例如崩溃或异常重启 ) 而导致连接未能正常关闭**，这将导致服务器端的连接断连。

   对于服务器主机而言，这可能会导致系统资源（尤指内存资源和 socket 资源）被耗尽而拒绝为新的用户请求提供服务。因此在实际应用中，服务器端需要采取相应的方法来探测 TCP 连接是否已经断连。

   

6. TCP连接和断开的状态转换（有限状态机）

<img src="C:\Users\Hanabi\AppData\Roaming\Typora\typora-user-images\image-20200728170226578.png" alt="image-20200728170226578" style="zoom:80%;" />



## Https

1. http协议和tcp协议的区别 

   **TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据，同时保证连接的可靠性。**

   HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP；在发送Http请求之前，先要通过TCP三次握手来建立连接，Http的每一次请求数据都会经过TCP包装。

   

2. https和http的区别 

   Http默认端口80，Https默认端口443。

   HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。

   HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗。

   

3. https的请求过程 

   - 客户端发送报文请求服务器，同时附带自己的SSL版本、加密算法等信息
   - 服务器返回**证书**（证书中有公钥信息、哈希算法）
   - 客户端验证证书的合法性（域名是否一致，CA机构是否是公认的，**数字签名**有没有问题）
   - 客户端使用证书中提供的**公钥加密**自己的**密钥**（双方协商生成），并发送给服务端（非对称加密）
   - 服务器使用**私钥**解析得到**客户端的密钥**（对称加密用的**密钥**），并使用这个**密钥**对响应信息进行加密并发还给客户端
   - 客户端使用自己的**密钥**解密得到服务端的响应数据，并以此进行通信（对称加密）

   CA证书：

   - CA机构将证书上所有东西进行哈希之后，使用**CA机构的私钥**进行**加密**成为**数字签名**，并附到证书上

   - 客户端使用提供的哈希算法将证书中除了数字签名以外的信息全部哈希一遍得到一个结果
   - 客户端使用**CA机构提供的公钥**将这个数字签名进行**解密**，得到的内容和自己哈希出来的结果应该一致

   **密钥**由**三个随机数**一起协商生成：

   - 客户端第一次向服务端发送请求时生成一个随机数（公开），同时提供一个**协商算法**
   - 服务端接收到请求后，发回证书等信息时，生成一个随机数（公开）
   - 客户端收到证书并校验完毕后，又生成一个随机数，并使用服务器提供的**公钥进行加密**（加密）
   - 双方根据协商算法，对以上三个随机数进行处理，得到对称加密使用的密钥

   

4. http协议的发展历程 

   HTTP1.0：主要是**短连接**

   HTTP1.1：支持**长连接**，**流水线请求**（Pipelining），引入更多**缓存控制策略**

   HTTP2.0：

   - 多路复用：将所有传输的信息分割为更小的消息和帧，并对它们采用**二进制格式**的编码，可以**乱序**发送并组装。一个request对应一个id，这样**一个连接上可以有多个request**，每个连接的request可以随机的混杂在一起，接收方可以根据**request的 id**将request再归属到各自不同的服务端请求里面。
- 头部压缩：对多次请求中几乎相同的请求头进行压缩
   - 随时复位：可以随时停止一个信息传输，而不用中断连接，提高带宽效率
   - 服务端推送：例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。



## 应用层

1. get请求和post请求的区别 

   **GET：从指定的资源请求数据。**

   - 反复读取不应该对访问的数据有副作用，即**幂等**。
   - 可以对GET请求的数据做缓存、保留在浏览器历史记录中、被收藏为书签。
   - 一些请求参数的键值对在URL中发送
   - GET请求有长度限制

   **POST：向指定的资源提交要被处理的数据**

   - POST请求会对数据进行改变或者操作，是会有副作用的，因而不幂等
   - 不能对POST请求做缓存（缓存一次提交订单的请求？）、保留历史记录、收藏为书签
   - 一些请求的参数是在HTTP消息的主体中发送的
   - POST请求没有长度限制



2. 在浏览器网址输入一个url后直到浏览器显示页面的过程**(这边面试官可能会详细的考察DNS服务器的知识)**  

- 使用**DNS**对域名进行解析，得到**IP地址**
- 通过TCP协议**三次握手**，与服务器建立连接
- 浏览器向服务器发送**Http请求**（附带cookies），请求中包含请求文件的位置、请求文件的方式等等
- 服务器处理请求（cookies、参数...）生成一个Html响应
- 服务器将Html响应发回客户机
- 浏览器接收并渲染Html并显示
- 连接结束，TCP四次挥手断开连接
- DNS缓存查找：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。



3. DNS解析过程、查找过程（www.baidu.com)

   DNS解析、查找过程

   1. 搜索缓存
      - **浏览器**搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；
      - 搜索**操作系统**中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；
      - 搜索操作系统的 **hosts 文件**（ Windows 环境下，维护一张域名与 IP 地址的对应表）；

   2. 操作系统将域名发送至 LDNS（**本地域名服务器**）**LDNS 查询自己的 DNS 缓存**，查找成功则返回结果，失败则发起一个**迭代** DNS 解析请求；
      - LDNS 向 Root Name Server （**根域名服务器**，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的**顶级域名服务器的地址**；
      - LDNS 向 com 域的顶级域名服务器发起请求，返回 [baidu.com](https://link.zhihu.com/?target=https%3A//www.baidu.com) 域名服务器地址；
      - LDNS 向 [baidu.com](https://link.zhihu.com/?target=https%3A//www.baidu.com) 域名服务器发起请求，得到 [www.baidu.com](https://link.zhihu.com/?target=http%3A//www.baidu.com/) 的 IP 地址；
   3. **LDNS** 将得到的 IP 地址返回给操作系统，同时自己也**将 IP 地址缓存起来**；
   4. **操作系统**将 IP 地址返回给浏览器，同时自己也**将 IP 地址缓存起来**；



## Http状态码

状态码主要是为了告知从服务器端返回的请求结果。

### 1. 2XX成功

请求正常处理完毕

- **200 OK** 从客户端发送的请求在服务端被正常处理了。
- **204 No Content** 服务器接受的请求已成功处理，但返回的响应报文的主体部分不包含实体（浏览器页面不更新，仅发送信息给服务器）
- **206 Partial Content** 客户端进行了范围请求，而服务器成功执行了这部分请求

### 2. 3XX重定向

浏览器需要执行某些特殊的处理以正确处理请求。

- **301 Moved Permanently** 永久性重定向，请求的资源已经分配了新的URI，以后应该使用资源现在所指的URI
- **302 Found** 临时性重定向，请求的资源临时分配了新的URI，希望用户本次可以使用新的URI访问
   注意：当301,302,303响应状态码返回时，几乎所有的浏览器会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送
- **304 Not Modified** 服务器端资源未改变，可直接使用客户端未过期的缓存，不包含任何响应的主体部分

### 3. 4XX客户端错误

客户端是发生错误的原因所在。

- **400 Bad Request**  请求报文中存在语法错误
- **401 Unauthorized** 请求需要有通过HTTP认证的认证信息。另外如果之前已进行一次请求，则表示用户认证失败
- **403 Forbidden** 对请求资源的访问被服务器拒绝了，如未获得文件系统的访问授权，访问权限出现某些问题
- **404 Not Found** 服务器上没有请求的资源
- **499 client has closed connection** 服务器端处理的时间过长，客户端主动断开链接，ngix定义的状态码

### 4. 5XX服务器错误

服务器是发生错误的原因所在。

- **500 Internal Server Error** 服务器在执行请求时发生了错误，Bug或临时故障
- **503 Service Unavailable** 服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求