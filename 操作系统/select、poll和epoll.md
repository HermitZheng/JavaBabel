 	epoll把epoll实例创建、events增删改还有events轮询都分开了，这样的话epoll实例就可以被同一个进程中的所有线程共享。epoll跟poll一样，使用链表节点记录监听events，但是它有三个链表型结构（就绪链表、辅助链表、红黑树），首先想**要监听的events的节点被放到红黑树里(epoll_ctl, 注册唤醒回调ep_poll_callback)**，这样可以加快events节点的访问。

​	**events就绪之后会被挂载到就绪链表里去**。ep_send_events_proc中，当epoll_wait**从内核空间向用户空间写出就绪events的时候，会遍历就绪链表通过文件poll方法获取发生的关心的events**，没有关心的events发生则无视（**有这步二次确认，所以LT中处理完成的事件不会使得epoll_wait返回**）。同时这个时候可能还会发生新的就绪events，这个时候已就绪的events不再添加到就绪链表里去，而是使用辅助链表**eventpoll.ovflist**... 

​	在epoll_wait调用中，epoll会**遍历就绪队列**里的每一个events节点，然后通过**文件的poll方法**再次获取事件的**最新状态revents**，然后把**该events节点从就绪链表中删除**。

​	当revents中包含我们关心的事件events的话，**LT模式还会把该节点重新加入到就绪队列里**，而ET模式也就是edge边界模式不会。这么做有什么影响呢，举个例子，假设我们监听一个管道可读，当事件就绪之后，我们只读了部分内容，还有部分内容没有读。**当我们再次epoll_wait的时候，对LT模式来说，就绪队列里还有这个事件的节点，再次获取状态做二次确认，如果依然可读还是不从就绪队列里删除，然后返回这个这个事件**；对ET模式来说，就绪队列里没有这个事件的节点了，所以也就不会再对它进行通知了。那LT模式中的这个事件节点什么时候被删除呢，**假设第一次epoll_wait的时候，我们把管道里的内容全部读完了，再最后一次epoll_wait返回时仍会放回就绪链表，但下次epoll_wait返回前遍历到这个节点然后重新获取它的状态的时候，它已经不再就绪了，因为管道空了**，**这个时候LT模式就不会再把这个节点重新添加到就绪队列里了，这时若没有其他事件，epoll_wait并不会返回，仅仅是在内核中有一些处理**。



​	即如果是LT模式，那么每次向用户交付events之后，再次把该epitem挂载到eventpoll中的就绪队列上，下一次epoll_wait()时不休眠直接进入到ep_send_events_proc()中来，通过获取资源文件的最新状态然后与我们关心的events比较：

1. 如果资源状态还是满足我们关心的events（可能是资源又就绪了，也有可能是上次就绪的资源未消费完），那么还是把它再次交付；
2. 如果不再满足我们关心的events（上一次的就绪资源已经消费完并且还没有再次就绪），那么将它从就绪队列上卸载之后（下一轮的ep_send_events_proc中，当epoll_wait**从内核空间向用户空间写出就绪events的时候，会遍历就绪链表并获取发生的关心的events**，没有关心的events发生则并不进行返回）可就不再重新挂载了...